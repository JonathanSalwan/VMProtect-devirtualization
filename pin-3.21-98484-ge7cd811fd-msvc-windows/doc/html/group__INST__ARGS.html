<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: Instrumentation arguments</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Instrumentation arguments</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPIN__MEM__ACCESS__INFO.html">PIN_MEM_ACCESS_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPIN__MULTI__MEM__ACCESS__INFO.html">PIN_MULTI_MEM_ACCESS_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIMULTI__ELEMENT__OPERAND.html">IMULTI_ELEMENT_OPERAND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionPIN__MEM__TRANS__FLAGS.html">PIN_MEM_TRANS_FLAGS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5d3025eb005b7ea4745799f0ee1b86a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga5d3025eb005b7ea4745799f0ee1b86a6">PIN_FAST_ANALYSIS_CALL</a></td></tr>
<tr class="separator:ga5d3025eb005b7ea4745799f0ee1b86a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafbeb707dc23c7c09e1e8c932649107d5"><td class="memItemLeft" align="right" valign="top">typedef IARGLIST_CLASS *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a></td></tr>
<tr class="separator:gafbeb707dc23c7c09e1e8c932649107d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga707ea08e31f44f4a81e2a7766123bad7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a> { <br />
&#160;&#160;<b>IPOINT_INVALID</b>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec">IPOINT_AFTER</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7acf7dee2063098dd79907d19f9c7df65d">IPOINT_ANYWHERE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d">IPOINT_TAKEN_BRANCH</a>
<br />
 }</td></tr>
<tr class="separator:ga707ea08e31f44f4a81e2a7766123bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1d5f6805cb16d00bce441290ca2212"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a> { <br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga3d1d5f6805cb16d00bce441290ca2212a3f53c3878be5c2859b82b540561b72b3">CALL_ORDER_FIRST</a> = 100, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga3d1d5f6805cb16d00bce441290ca2212a43af3c7aa24c81dddf629b2828b8354c">CALL_ORDER_DEFAULT</a> = 200, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga3d1d5f6805cb16d00bce441290ca2212a0b197a15a2399e6443ce6be187ccf6c6">CALL_ORDER_LAST</a> = 300
<br />
 }</td></tr>
<tr class="separator:ga3d1d5f6805cb16d00bce441290ca2212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089c27ca15e9ff139dd3a3f8a6f8451d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a> { <br />
&#160;&#160;<b>IARG_INVALID</b>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da34126f334d65afac69784351a03615ad">IARG_ADDRINT</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da7a11763427dff3afb81caab97b02881b">IARG_PTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dacac3cb99011b351eeb3f675bc8c62b83">IARG_BOOL</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd">IARG_UINT32</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dab2d3f91c48319ea5e824fdc678ae4a5c">IARG_UINT64</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dabe70796bf61230dac3ea1deaf4983c46">IARG_REG_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0337fbb99845733a3d35a9a3dbcfbf93">IARG_REG_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da817f3f2fe8c0c536daa86deb55126c25">IARG_REG_CONST_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da2138787daf04a57e6684eb0b368e120e">IARG_MEMORYREAD_EA</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da2931627e96b437dc55e06966d31ad962">IARG_MEMORYREAD2_EA</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da92be352ec619bbd3be69fed773c011a2">IARG_MEMORYWRITE_EA</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad2e2d24103d1a0286b57412f66b909d7">IARG_MEMORYREAD_SIZE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da365d8eed26ac239b013a01ab6a7cf375">IARG_MEMORYWRITE_SIZE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da4b127f5e8c89aabe67abb6d04ee8ecce">IARG_MEMORYREAD_PTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da96d283a176b568500d63a7b8ad2558ed">IARG_MEMORYREAD2_PTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da9fead51aa9d72879eadd61ae5cb00e98">IARG_MEMORYWRITE_PTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da52ab7563efadafe484b53421e42ec8b1">IARG_MEMORYOP_PTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451daa60ade75a81b448320631155e84829a6">IARG_MULTI_MEMORYACCESS_EA</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c">IARG_MULTI_ELEMENT_OPERAND</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da87c9a713268fea1c9ddb157aa0a475eb">IARG_EXPLICIT_MEMORY_EA</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da28140354d575f6b6404a6833552fed47">IARG_BRANCH_TAKEN</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451daa1b650f4229df434f3ac5ef61f14d0ed">IARG_BRANCH_TARGET_ADDR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0faf9829bd4f46cc1873c943978b21d7">IARG_FALLTHROUGH_ADDR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da5f291cb55a7d61a40fa3ab98e191394e">IARG_EXECUTING</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da4e8c634973d6966dba21ff70455c1f5b">IARG_FIRST_REP_ITERATION</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da8cbb1c02c9e1bad259570179580adb50">IARG_PREDICATE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dacd300aa37115a80c4ce30e11e7a37846">IARG_STACK_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0ea57a2ba5c26fe0b0e7d75a8de06fee">IARG_STACK_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da2b71d3e92a6b768857bd60cd1ffb67bb">IARG_MEMORY_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad99d33d82bec02d9dc8c1639c90920a2">IARG_MEMORY_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da6e903286d783f6ee402e146b8dff871f">IARG_SYSCALL_NUMBER</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dacf2d3d2c61544c89918563331a73b2f4">IARG_SYSARG_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da53b9c85f47960f7b805dc0bb8b6a1a2e">IARG_SYSARG_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0480757dd8ff829a67621df1e9e5396d">IARG_SYSRET_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da969a0228ddab7219f20426504991b676">IARG_SYSRET_ERRNO</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da4babc2672f5a58d94f8fb8f5234c14d4">IARG_FUNCARG_CALLSITE_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da8766561ec59dfb16a94edb3624f53ab8">IARG_FUNCARG_CALLSITE_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dab23dff2bab780c074d4998d14f4ecb16">IARG_FUNCARG_ENTRYPOINT_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da78065c99b8462ff353115dc9f6419931">IARG_FUNCRET_EXITPOINT_REFERENCE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da19dc8d3703330b7b1e1064336dd235cf">IARG_FUNCRET_EXITPOINT_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da2c4a6ff4e8a076e0f39d24ab73ec7092">IARG_RETURN_IP</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295">IARG_ORIG_FUNCPTR</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad12677dad18848be51b49ea0f48e07cb">IARG_PROTOTYPE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4">IARG_THREAD_ID</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da6c8569ef37241134ffc6e24593275981">IARG_RETURN_REGS</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dae11c26daf8993e626359a566d35d46d0">IARG_IARGLIST</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da892dbdf11883df94c327bb31fd0d5fcd">IARG_FAST_ANALYSIS_CALL</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63">IARG_MEMORYOP_EA</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451daa5b738f4179d2b6313ac517be1f5221d">IARG_MEMORYOP_SIZE</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da821b74fed6ac3d8740d73245b4f26a06">IARG_MEMORYOP_MASKED_ON</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da30acbbeded5e7e293324f81cc796ef7d">IARG_TSC</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da2d2d4502ddc8de6d717c6878101c73df">IARG_FILE_NAME</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da5a86209c9f24bebb204f1c435eb18d1c">IARG_LINE_NO</a>, 
<br />
&#160;&#160;<a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad1fd7d0ac8f175d5340787ff3f3a2093">IARG_LAST</a>
<br />
 }</td></tr>
<tr class="separator:ga089c27ca15e9ff139dd3a3f8a6f8451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624ddd00f45938da5eb525afc5b43195"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga624ddd00f45938da5eb525afc5b43195">PIN_MEMOP_ENUM</a> { <br />
&#160;&#160;<b>PIN_MEMOP_LOAD</b>, 
<br />
&#160;&#160;<b>PIN_MEMOP_STORE</b>
<br />
 }</td></tr>
<tr class="separator:ga624ddd00f45938da5eb525afc5b43195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b7ac266c4c1323b18396be70279eb0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga16b7ac266c4c1323b18396be70279eb0">PIN_OP_ELEMENT_ACCESS</a> { <br />
&#160;&#160;<b>PIN_OP_ELEMENT_ACCESS_READ</b>, 
<br />
&#160;&#160;<b>PIN_OP_ELEMENT_ACCESS_WRITE</b>, 
<br />
&#160;&#160;<b>PIN_OP_ELEMENT_ACCESS_READWRITE</b>
<br />
 }</td></tr>
<tr class="separator:ga16b7ac266c4c1323b18396be70279eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga85838e12fe04880ed61c5c60378c0147"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga85838e12fe04880ed61c5c60378c0147">IARGLIST_AddArguments</a> (<a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a> args,...)</td></tr>
<tr class="separator:ga85838e12fe04880ed61c5c60378c0147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d3e1e48b6fe3d71cb9f04a202ac55d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga3d3e1e48b6fe3d71cb9f04a202ac55d7">IARGLIST_Alloc</a> ()</td></tr>
<tr class="separator:ga3d3e1e48b6fe3d71cb9f04a202ac55d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30472edf4c557377c7f6bc73601d0a90"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INST__ARGS.html#ga30472edf4c557377c7f6bc73601d0a90">IARGLIST_Free</a> (<a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a> args)</td></tr>
<tr class="separator:ga30472edf4c557377c7f6bc73601d0a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga2a86c3c95b207c7c02b7b5c64311dd09"><td class="memItemLeft" align="right" valign="top"><a id="ga2a86c3c95b207c7c02b7b5c64311dd09"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_MULTI_MEMOPS</b> = 16</td></tr>
<tr class="separator:ga2a86c3c95b207c7c02b7b5c64311dd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>See <a class="el" href="group__INS__INSTRUMENTATION.html#gaea02f152d3515f4758b8f979a380da09">INS_InsertCall</a>.</p>
<h1><a class="anchor" id="SEC_IARG_END"></a>
IARG_END</h1>
<p>All argument lists must end with IARG_END. Please see the <a class="el" href="index.html#EXAMPLES">Examples</a> for further information.</p>
<h1><a class="anchor" id="PROBE_IARGS"></a>
Probe Mode Considerations</h1>
<p>When IARG_CONTEXT is used in probe mode, it is impossible to get certain register values correct. The values in these registers are meaningless when IARG_CONTEXT is used in probe mode:</p>
<p>REG_SEG_GS_BASE <br />
 REG_SEG_FS_BASE <br />
 REG_INST_G0 - REG_INST_G19 <br />
 Using <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da6c8569ef37241134ffc6e24593275981">IARG_RETURN_REGS</a>, <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0337fbb99845733a3d35a9a3dbcfbf93">IARG_REG_REFERENCE</a>, <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> and <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> is not supported in Probe mode.</p>
<h1><a class="anchor" id="NO_INLINE_IARGS"></a>
Inlining Considerations</h1>
<p>The <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> and <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> IARG_TYPE cannot be inlined. Using these <a class="el" href="structCONTEXT.html">CONTEXT</a> IARG_TYPE will prevent the analysis routine from being inlined. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga5d3025eb005b7ea4745799f0ee1b86a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3025eb005b7ea4745799f0ee1b86a6">&#9670;&nbsp;</a></span>PIN_FAST_ANALYSIS_CALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIN_FAST_ANALYSIS_CALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use a faster linkage for calls to analysis functions. Add PIN_FAST_ANALYSIS_CALL to the declaration between the return type and the function name. You must also add <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da892dbdf11883df94c327bb31fd0d5fcd">IARG_FAST_ANALYSIS_CALL</a> to the InsertCall. For example:</p>
<p>VOID PIN_FAST_ANALYSIS_CALL docount(int j);</p>
<p>INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(docount), IARG_FAST_ANALYSIS_CALL, IARG_UINT32, 3, IARG_END); </p>
<p>You will gain the most benefit from using PIN_FAST_ANALYSIS_CALL if</p><ul>
<li>you are instrumenting a 32 bit process (the 64 bit calling conventions already pass arguments in registers)</li>
<li>your analysis routine is not inlined (if it is inlined there is no call to optimize)</li>
<li>your analysis routine is relatively small (if it is large the extra overhead imposed by the poor calling convention won't be significant anyway) </li>
</ul>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gafbeb707dc23c7c09e1e8c932649107d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbeb707dc23c7c09e1e8c932649107d5">&#9670;&nbsp;</a></span>IARGLIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IARGLIST_CLASS* <a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of IARG_TYPE elements. See <a class="el" href="group__INST__ARGS.html#ga3d3e1e48b6fe3d71cb9f04a202ac55d7">IARGLIST_Alloc()</a> for its use. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3d1d5f6805cb16d00bce441290ca2212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1d5f6805cb16d00bce441290ca2212">&#9670;&nbsp;</a></span>CALL_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predefined values for <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a>. Controls the order of analysis call invocations when an instruction has multiple analysis calls. CALL_ORDER_DEFAULT is the default call order when <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6">IARG_CALL_ORDER</a> is not specified. You can use integral values relative to the predefined values to have a fine-grained control over the instrumentation order (e.g., CALL_ORDER_DEFAULT + 5, CALL_ORDER_LAST - 10, etc).</p>
<p>Pin guarantees that multiple analysis calls with the same CALL_ORDER on the same instruction, added in the context of the same instrumentation callback (e.g,. <a class="el" href="group__INS__INSTRUMENTATION.html#INS_INSTRUMENT_CALLBACK">INS_INSTRUMENT_CALLBACK</a>), will be invoked according to their insertion order. For all other cases, the invocation order for analysis calls with the same CALL_ORDER on the same instruction depends on the implementation and may change without notice. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3d1d5f6805cb16d00bce441290ca2212a3f53c3878be5c2859b82b540561b72b3"></a>CALL_ORDER_FIRST&#160;</td><td class="fielddoc"><p>Execute this call first. Value is 100. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3d1d5f6805cb16d00bce441290ca2212a43af3c7aa24c81dddf629b2828b8354c"></a>CALL_ORDER_DEFAULT&#160;</td><td class="fielddoc"><p>Default when IARG_CALL_ORDER is not specified. Value is 200. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3d1d5f6805cb16d00bce441290ca2212a0b197a15a2399e6443ce6be187ccf6c6"></a>CALL_ORDER_LAST&#160;</td><td class="fielddoc"><p>Execute this call last. Value is 300. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga089c27ca15e9ff139dd3a3f8a6f8451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga089c27ca15e9ff139dd3a3f8a6f8451d">&#9670;&nbsp;</a></span>IARG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the arguments that are passed to the analysis call. All argument lists must end with IARG_END. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da34126f334d65afac69784351a03615ad"></a>IARG_ADDRINT&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Constant value (additional arg required) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da7a11763427dff3afb81caab97b02881b"></a>IARG_PTR&#160;</td><td class="fielddoc"><p>Type: "VOID *". Constant value (additional pointer arg required) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dacac3cb99011b351eeb3f675bc8c62b83"></a>IARG_BOOL&#160;</td><td class="fielddoc"><p>Type: BOOL. Constant (additional BOOL arg required) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dabd19b79248899659441e56e4738d5bfd"></a>IARG_UINT32&#160;</td><td class="fielddoc"><p>Type: UINT32. Constant (additional integer arg required) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dab2d3f91c48319ea5e824fdc678ae4a5c"></a>IARG_UINT64&#160;</td><td class="fielddoc"><p>Type: UINT64. Constant (additional UINT64 arg required) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da623ad95758bce14fcb9427beef53736a"></a>IARG_INST_PTR&#160;</td><td class="fielddoc"><p>Type: ADDRINT. The address of the instrumented instruction. This value does not change at IPOINT_AFTER. This is simply shorthand for <code>IARG_ADDRINT, INS_Address(ins)</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dabe70796bf61230dac3ea1deaf4983c46"></a>IARG_REG_VALUE&#160;</td><td class="fielddoc"><p>Type: ADDRINT for integer registers. Value of a register (additional register arg required) <a class="el" href="group__REG.html">REG: Register Object</a> Basically, this cannot be used to retrieve the value of registers whose size is larger than ADDRINT (e.g. x87 FPU/XMM/YMM/ZMM/opmask) or registers which are not architectural (REG_PIN_*), but there are some exceptions to this rule. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da0337fbb99845733a3d35a9a3dbcfbf93"></a>IARG_REG_REFERENCE&#160;</td><td class="fielddoc"><p>Type: <a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a>. Pointer to union holding register content up to largest vector register size (ZMM - 64 bytes). Register is specified in additional argument. Type: <a class="el" href="unionPIN__WIDE__REGISTER.html">PIN_WIDE_REGISTER</a>. Pointer to union holding tile register contents (1024 bytes). Register is specified in additional argument. Register is updated back to the relevant application register (Meaning if you change values in the mentioned union they will be propagated to the relevant application register). If you're not interested in modifying the register value, but only read its value use IARG_REG_CONST_REFERENCE instead.</p>
<p>Not supported in Probe mode or with the Buffering APIs.</p>
<dl class="section note"><dt>Note</dt><dd>additional REG arg required!!! </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da817f3f2fe8c0c536daa86deb55126c25"></a>IARG_REG_CONST_REFERENCE&#160;</td><td class="fielddoc"><p>Type: <a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a>. Pointer to union holding register content up to largest vector register size (ZMM - 64 bytes). Register is specified in additional argument. Type: <a class="el" href="unionPIN__WIDE__REGISTER.html">PIN_WIDE_REGISTER</a>. Pointer to union holding tile register contents (1024 bytes). Register is specified in additional argument. Registers are not updated back to the relevant application register (Meaning if you change values in the mentioned union they will not be propagated to the relevant application register). If you're interested in modifying the register value, use IARG_REG_REFERENCE instead. Not supported with the Buffering APIs.</p>
<dl class="section note"><dt>Note</dt><dd>additional REG arg required!!! </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da2138787daf04a57e6684eb0b368e120e"></a>IARG_MEMORYREAD_EA&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Effective address of a memory read, only valid if INS_IsMemoryRead is true and at IPOINT_BEFORE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da2931627e96b437dc55e06966d31ad962"></a>IARG_MEMORYREAD2_EA&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Effective address of a 2nd memory read (e.g. 2nd operand in cmps on ia32), only valid at IPOINT_BEFORE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da92be352ec619bbd3be69fed773c011a2"></a>IARG_MEMORYWRITE_EA&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Effective address of a memory write, only valid at IPOINT_BEFORE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dad2e2d24103d1a0286b57412f66b909d7"></a>IARG_MEMORYREAD_SIZE&#160;</td><td class="fielddoc"><p>Type: UINT32. Size in bytes of memory read. This IARG is applicable for all instructions for which INS_hasKnownMemorySize returns TRUE. For other instructions e.g. vgather/vscatter see <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c">IARG_MULTI_ELEMENT_OPERAND</a>. For the varying memory size read instruction, XRSTOR, the size is based on the XSAVE area header. If the header indicates compact mode it will provide the compact size. Otherwise it will provide the standard size. The minimum size for the XRSTOR instruction (not including FXRSTOR) is 576 (i.e the XSAVE area size up to and including the header). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da365d8eed26ac239b013a01ab6a7cf375"></a>IARG_MEMORYWRITE_SIZE&#160;</td><td class="fielddoc"><p>Type: UINT32. Size in bytes of memory write. This IARG is applicable for all instructions for which INS_hasKnownMemorySize returns TRUE. For other instructions e.g. vgather/vscatter see <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c">IARG_MULTI_ELEMENT_OPERAND</a>. For varying size memory write instructions, the supported instructions are the XSAVE family of instructions. For XSAVE, the size of the XSAVE area used is based on user request and supported features in the machine. This will provide the exact size used. For XSAVEOPT, the size is calculated the same as if XSAVE was used. This may provide in some cases an upper bound to the actual used memory. For XSAVEC, in IPOINT_BEFORE the size is calculated based on user request only. This may provide in some cases an upper bound to the actual size. If used in IPOINT_AFTER it will provide the exact compact size as defined in the XSAVE area header. The minimum size for the XSAVE family write instructions (not including FXSAVE) is 576 (i.e the XSAVE area size up to and including the header). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da4b127f5e8c89aabe67abb6d04ee8ecce"></a>IARG_MEMORYREAD_PTR&#160;</td><td class="fielddoc"><p>Actual address of the memory access; same as <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da2138787daf04a57e6684eb0b368e120e">IARG_MEMORYREAD_EA</a>, unless the memory address is translated by <a class="el" href="group__PIN__CONTROL.html#ga3a5f26e35e32bc5e99d101995339bd73">MEMORY_ADDR_TRANS_CALLBACK</a>, or the memory operand is rewritten by <a class="el" href="group__INS__MODIFICATION.html#gaad5f037e311aa30dbc53e602e6ff672b">INS_RewriteMemoryOperand</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da96d283a176b568500d63a7b8ad2558ed"></a>IARG_MEMORYREAD2_PTR&#160;</td><td class="fielddoc"><p>Actual address of the memory access; same as <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da2931627e96b437dc55e06966d31ad962">IARG_MEMORYREAD2_EA</a>, unless the memory address is translated by <a class="el" href="group__PIN__CONTROL.html#ga3a5f26e35e32bc5e99d101995339bd73">MEMORY_ADDR_TRANS_CALLBACK</a>, or the memory operand is rewritten by <a class="el" href="group__INS__MODIFICATION.html#gaad5f037e311aa30dbc53e602e6ff672b">INS_RewriteMemoryOperand</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da9fead51aa9d72879eadd61ae5cb00e98"></a>IARG_MEMORYWRITE_PTR&#160;</td><td class="fielddoc"><p>Actual address of the memory access. Same as <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da92be352ec619bbd3be69fed773c011a2">IARG_MEMORYWRITE_EA</a>, unless the memory address is translated by <a class="el" href="group__PIN__CONTROL.html#ga3a5f26e35e32bc5e99d101995339bd73">MEMORY_ADDR_TRANS_CALLBACK</a>, or the memory operand is rewritten by <a class="el" href="group__INS__MODIFICATION.html#gaad5f037e311aa30dbc53e602e6ff672b">INS_RewriteMemoryOperand</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da52ab7563efadafe484b53421e42ec8b1"></a>IARG_MEMORYOP_PTR&#160;</td><td class="fielddoc"><p>Actual address of the memory access. Same as <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63">IARG_MEMORYOP_EA</a>, unless the memory address is translated by <a class="el" href="group__PIN__CONTROL.html#ga3a5f26e35e32bc5e99d101995339bd73">MEMORY_ADDR_TRANS_CALLBACK</a>, or the memory operand is rewritten by <a class="el" href="group__INS__MODIFICATION.html#gaad5f037e311aa30dbc53e602e6ff672b">INS_RewriteMemoryOperand</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451daa60ade75a81b448320631155e84829a6"></a>IARG_MULTI_MEMORYACCESS_EA&#160;</td><td class="fielddoc"><p>Type: PIN_MULTI_MEM_ACCESS_INFO* the addresses read by the various vgather* instructions, Also available for regular memory instructions </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da581b5886a7e69629a45607ac34adbf2c"></a>IARG_MULTI_ELEMENT_OPERAND&#160;</td><td class="fielddoc"><p>Type: IMULTI_ELEMENT_OPERAND* . Information about a multi element operand (implemented for IPOINT_BEFORE). The operand index is required as the next argument. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da87c9a713268fea1c9ddb157aa0a475eb"></a>IARG_EXPLICIT_MEMORY_EA&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Effective address of the explicit memory operand. Useful for instrumenting LEA instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da28140354d575f6b6404a6833552fed47"></a>IARG_BRANCH_TAKEN&#160;</td><td class="fielddoc"><p>Type: BOOL. Non zero if a branch is taken. Argument is invalid for XBEGIN and XEND instructions. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451daa1b650f4229df434f3ac5ef61f14d0ed"></a>IARG_BRANCH_TARGET_ADDR&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Target address of branch instruction.<br />
 In case of INS instrumentation, valid when <a class="el" href="group__INS__INSPECTION.html#ga308d89e7d9f39b8a0daf908778513457">INS_IsControlFlow()</a> is true.<br />
 However, this argument is invalid if the instruction is XBEGIN or XEND. In Linux, for the case of branching into the vsyscall area (in kernel 5.3 or above), the target address that will be received in the analysis routine would be that of the vsyscall area. Note that this address is not readable (e.g. via <a class="el" href="group__PIN__CONTROL.html#ga1225706d213f4bd1d81ed1fb32e792d7">PIN_SafeCopy()</a> and <a class="el" href="group__PIN__CONTROL.html#gabd8df83bbd040dfaf019bf18ec072b92">PIN_FetchCode()</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da0faf9829bd4f46cc1873c943978b21d7"></a>IARG_FALLTHROUGH_ADDR&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Fall through address of the instrumented object.<br />
 In case of INS instrumentation, valid only if <a class="el" href="group__INS__INSPECTION.html#ga7602edb17e52e209492bab2c65fc1612">INS_HasFallThrough()</a> is true. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da5f291cb55a7d61a40fa3ab98e191394e"></a>IARG_EXECUTING&#160;</td><td class="fielddoc"><p>Type: BOOL. False if the instruction will not be executed because of predication, otherwise true. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da4e8c634973d6966dba21ff70455c1f5b"></a>IARG_FIRST_REP_ITERATION&#160;</td><td class="fielddoc"><p>Type: BOOL. True if INS_HasRealRep(ins) and this the first iteration of the REP sequence, otherwise false.<br />
 </p><dl class="section note"><dt>Note</dt><dd>In case count register is 0 when calling analysis routine, the value of IARG_FIRST_REP_ITERATION is false. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da8cbb1c02c9e1bad259570179580adb50"></a>IARG_PREDICATE&#160;</td><td class="fielddoc"><p>Reserved. Do not use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dacd300aa37115a80c4ce30e11e7a37846"></a>IARG_STACK_VALUE&#160;</td><td class="fielddoc"><p>Reserved. Do not use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da0ea57a2ba5c26fe0b0e7d75a8de06fee"></a>IARG_STACK_REFERENCE&#160;</td><td class="fielddoc"><p>Reserved. Do not use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da2b71d3e92a6b768857bd60cd1ffb67bb"></a>IARG_MEMORY_VALUE&#160;</td><td class="fielddoc"><p>Reserved. IA32(e) only. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dad99d33d82bec02d9dc8c1639c90920a2"></a>IARG_MEMORY_REFERENCE&#160;</td><td class="fielddoc"><p>Reserved. IA32(e) only. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da6e903286d783f6ee402e146b8dff871f"></a>IARG_SYSCALL_NUMBER&#160;</td><td class="fielddoc"><p>Type: ADDRINT. System call number. Valid for IPOINT_BEFORE at the system call instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dacf2d3d2c61544c89918563331a73b2f4"></a>IARG_SYSARG_REFERENCE&#160;</td><td class="fielddoc"><p>Type: "ADDRINT *". Pointer to system call argument n. Valid for IPOINT_BEFORE at the system call instruction. (First argument number is 0.) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da53b9c85f47960f7b805dc0bb8b6a1a2e"></a>IARG_SYSARG_VALUE&#160;</td><td class="fielddoc"><p>Type: ADDRINT. System call argument n. Valid for IPOINT_BEFORE at the system call instruction. (First argument number is 0.) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da0480757dd8ff829a67621df1e9e5396d"></a>IARG_SYSRET_VALUE&#160;</td><td class="fielddoc"><p>Type: ADDRINT. System call return value. On Linux and macOS* the value is -1 if the system call failed. (IPOINT_AFTER only) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da969a0228ddab7219f20426504991b676"></a>IARG_SYSRET_ERRNO&#160;</td><td class="fielddoc"><p>Type: INT32. System call errno (IPOINT_AFTER_only). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da4babc2672f5a58d94f8fb8f5234c14d4"></a>IARG_FUNCARG_CALLSITE_REFERENCE&#160;</td><td class="fielddoc"><p>Type: "ADDRINT *". Pointer to integer argument n. Valid only at the call site. (First argument number is 0.) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da8766561ec59dfb16a94edb3624f53ab8"></a>IARG_FUNCARG_CALLSITE_VALUE&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Integer argument n. Valid only at the call site. (First argument number is 0.) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dab23dff2bab780c074d4998d14f4ecb16"></a>IARG_FUNCARG_ENTRYPOINT_REFERENCE&#160;</td><td class="fielddoc"><p>Type: "ADDRINT *". Pointer to integer argument n. Valid only at the entry point of a routine. (First argument number is 0.) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dab418d242314ea7c67b1febf7667e93a1"></a>IARG_FUNCARG_ENTRYPOINT_VALUE&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Integer argument n. Valid only at the entry point of a routine. (First argument number is 0.) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da78065c99b8462ff353115dc9f6419931"></a>IARG_FUNCRET_EXITPOINT_REFERENCE&#160;</td><td class="fielddoc"><p>Type: "ADDRINT *". Pointer to function result. Valid only at return instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da19dc8d3703330b7b1e1064336dd235cf"></a>IARG_FUNCRET_EXITPOINT_VALUE&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Function result. Valid only at return instruction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da2c4a6ff4e8a076e0f39d24ab73ec7092"></a>IARG_RETURN_IP&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Return address for function call, valid only at the function entry point. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da0425900c8991df5d840dd6d9f9b03295"></a>IARG_ORIG_FUNCPTR&#160;</td><td class="fielddoc"><p>Type: AFUNPTR. Function pointer to the relocated entry of the original uninstrumented function. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dad12677dad18848be51b49ea0f48e07cb"></a>IARG_PROTOTYPE&#160;</td><td class="fielddoc"><p>Type: PROTO. The function prototype of the application function. See <a class="el" href="group__PROTO.html">PROTO API</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451daadb6e5681193cc8435b9e57d13acf5d4"></a>IARG_THREAD_ID&#160;</td><td class="fielddoc"><p>Type: THREADID. Application thread id. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d"></a>IARG_CONTEXT&#160;</td><td class="fielddoc"><p>Type: <a class="el" href="group__CONTEXT.html">Context manipulation API</a> *. Handle to access a context (architectural state). When passed at <a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec">IPOINT_AFTER</a> or <a class="el" href="group__INST__ARGS.html#gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d">IPOINT_TAKEN_BRANCH</a>, PC points to the next instruction. Upon return from the analysis routine, Pin ignores any changes you've made to the <a class="el" href="group__CONTEXT.html">Context manipulation API</a>. If you want to change register values, use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da0337fbb99845733a3d35a9a3dbcfbf93">IARG_REG_REFERENCE</a>, <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da6c8569ef37241134ffc6e24593275981">IARG_RETURN_REGS</a>, or <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a>. See <a class="el" href="group__INST__ARGS.html#PROBE_IARGS">Probe Mode Considerations</a> for probe mode restrictions. Not supported with the Buffering APIs. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45"></a>IARG_CONST_CONTEXT&#160;</td><td class="fielddoc"><p>Type: <a class="el" href="group__CONTEXT.html">Context manipulation API</a> *. Like <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, but tool receives a read-only <a class="el" href="group__CONTEXT.html">Context manipulation API</a>*. <a class="el" href="group__CONTEXT.html#ga83c0549f92440cf717c08689c47127cd">PIN_SetContextReg</a>, <a class="el" href="group__CONTEXT.html#gae96c2fa413d6009f9775cfebab49912f">PIN_SetContextRegval</a> and <a class="el" href="group__CONTEXT.html#ga147e92f2d15f95bd43cb6c8ea19057f4">PIN_SetContextFPState</a> will not work with <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. The overhead of <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> is considerably lower than that of <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>. Tools that need a <a class="el" href="group__CONTEXT.html">Context manipulation API</a>* and only read from it should use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. Tools that need a <a class="el" href="group__CONTEXT.html">Context manipulation API</a>* and only occasionally write into it should also use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. One example of a tool that needs a <a class="el" href="group__CONTEXT.html">Context manipulation API</a> * and only occasionally writes into it, would be an emulator that would need to write into the <a class="el" href="group__CONTEXT.html">Context manipulation API</a> * only when an exception occurs, and then raise an exception with the <a class="el" href="group__CONTEXT.html">Context manipulation API</a> *. <a class="el" href="group__CONTEXT.html#gabd0a55669ab303520f82e4f512e084f9">PIN_SaveContext</a> can be used by the tool to get a writable copy of the <a class="el" href="group__CONTEXT.html">Context manipulation API</a> *. <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a> is available only in Jit mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29"></a>IARG_PARTIAL_CONTEXT&#160;</td><td class="fielddoc"><p>Type: <a class="el" href="group__CONTEXT.html">Context manipulation API</a> *. Additional two <a class="el" href="group__REG.html#ga8a33ca031ce83cf24d58dca8adf19f6c">REGSET</a> * arguments are needed 'inSet' and 'outSet'. Like <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>, but tool needs to define also which registers set it needs to read (inSet) and which registers set it may write (outSet). <a class="el" href="group__CONTEXT.html#ga83c0549f92440cf717c08689c47127cd">PIN_SetContextReg</a>, <a class="el" href="group__CONTEXT.html#gae96c2fa413d6009f9775cfebab49912f">PIN_SetContextRegval</a> and <a class="el" href="group__CONTEXT.html#ga147e92f2d15f95bd43cb6c8ea19057f4">PIN_SetContextFPState</a> will work only on registers that are in the outSet. These functions will change the actual application registers so there is no need to perform <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a> as need to be done with <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>. <a class="el" href="group__CONTEXT.html#ga5b5aea73f92ac62e0767cb32bf8de4ed">PIN_GetContextReg</a>, <a class="el" href="group__CONTEXT.html#ga44f8eeba2b8b874087441df1c3a530e2">PIN_GetContextRegval</a> and <a class="el" href="group__CONTEXT.html#ga628d9e2f229dc5101142c94a5411d073">PIN_GetContextFPState</a> will return unexpected values for registers not defined in the 'inSet'. The overhead of <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> may lower than that of <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a> as there is no need to perform <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a> to update registers. Tools that know which application registers are needed to be read should use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> instead of <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dad3e65d643a63acb09d12b8538434ca45">IARG_CONST_CONTEXT</a>. Thus may reduce the overhead as not fully updated context for read need to be provided. Tools that know which application registers other than REG_INST_PTR should use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> instead of combination of <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a> and the use of <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a> for registers update. If REG_INST_PTR needs to be updated <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a> still needs to be used. Any updates to a register from the inSet of an <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> will be propagated to the application upon return from the analysis routine. Tools that want to update <a class="el" href="group__CONTEXT.html">Context manipulation API</a> registers without affecting application registers should use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da25577a47a3c3945080ce1429959f3f1d">IARG_CONTEXT</a>. <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> is available only in Jit mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da9289568da718031f0b70921f9ca4d0c8"></a>IARG_PRESERVE&#160;</td><td class="fielddoc"><p>Type: <a class="el" href="group__REG.html#ga8a33ca031ce83cf24d58dca8adf19f6c">REGSET</a> *. Used to specify registers whose values will be the same upon return from the analysis routine. Should be used to specify caller-saved registers which are preserved by the analysis routine. When a non-inlinable analysis routine preserves caller-saved registers, Pin can avoid generating code to preserve these registers, across the analysis call, if they are specified in the IARG_PRESERVE. e.g. if a non-inlinable analysis routine preserves the values in the x87 registers, then Pin can avoid generating code to preserve these registers, across the analysis call, if REG_X87 is specified in the <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a> e.g. if a non-inlinable analysis routine preserves the values in XMM caller saved registers, then Pin can avoid generating code to preserve these registers, across the analysis call, if those preserved XMM registers are specified in the <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a> <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451da9289568da718031f0b70921f9ca4d0c8">IARG_PRESERVE</a> must be followed by a <a class="el" href="group__REG.html#ga8a33ca031ce83cf24d58dca8adf19f6c">REGSET</a>* that points to the <a class="el" href="group__REG.html#ga8a33ca031ce83cf24d58dca8adf19f6c">REGSET</a> containing the registers preserved. See the <a class="el" href="group__REG.html#ga0d287d13f9dc3f2fbffe24f217e12674">(REGSET_*)</a> functions defined under <a class="el" href="group__REG.html">REG: Register Object</a> for <a class="el" href="group__REG.html#ga8a33ca031ce83cf24d58dca8adf19f6c">REGSET</a> construction and manipulation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da6c8569ef37241134ffc6e24593275981"></a>IARG_RETURN_REGS&#160;</td><td class="fielddoc"><p>Register to write analysis function return value (additional register arg required). Not supported in Probe mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da45b6bfd69845ada4a0875967995ad7c6"></a>IARG_CALL_ORDER&#160;</td><td class="fielddoc"><p>Type: CALL_ORDER. Determine order of analysis calls. See <a class="el" href="group__INST__ARGS.html#ga3d1d5f6805cb16d00bce441290ca2212">CALL_ORDER</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dae11c26daf8993e626359a566d35d46d0"></a>IARG_IARGLIST&#160;</td><td class="fielddoc"><p>Type: IARGLIST. List of IARGS which can be constructed one IARG at a time. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da892dbdf11883df94c327bb31fd0d5fcd"></a>IARG_FAST_ANALYSIS_CALL&#160;</td><td class="fielddoc"><p>No type: Use a fast linkage to call the analysis function. See <a class="el" href="group__INST__ARGS.html#ga5d3025eb005b7ea4745799f0ee1b86a6">PIN_FAST_ANALYSIS_CALL</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da985747a3c70e3a4283fc8a2f16399e63"></a>IARG_MEMORYOP_EA&#160;</td><td class="fielddoc"><p>Type: ADDRINT. Effective address of a memory op (memory op index is next arg); only valid at IPOINT_BEFORE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451daa5b738f4179d2b6313ac517be1f5221d"></a>IARG_MEMORYOP_SIZE&#160;</td><td class="fielddoc"><p>Type: UINT32. Size of a memory op (memory op index is next arg) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da821b74fed6ac3d8740d73245b4f26a06"></a>IARG_MEMORYOP_MASKED_ON&#160;</td><td class="fielddoc"><p>Type: BOOL. TRUE if the this memory op (memory op index is next arg) is masked on; only valid at IPOINT_BEFORE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da30acbbeded5e7e293324f81cc796ef7d"></a>IARG_TSC&#160;</td><td class="fielddoc"><p>Type: UINT64. Time Stamp Counter value at the point of entering the analysis call. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da2d2d4502ddc8de6d717c6878101c73df"></a>IARG_FILE_NAME&#160;</td><td class="fielddoc"><p>Reserved for internal use only. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451da5a86209c9f24bebb204f1c435eb18d1c"></a>IARG_LINE_NO&#160;</td><td class="fielddoc"><p>Reserved for internal use only. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga089c27ca15e9ff139dd3a3f8a6f8451dad1fd7d0ac8f175d5340787ff3f3a2093"></a>IARG_LAST&#160;</td><td class="fielddoc"><p>Reserved for internal use only. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga707ea08e31f44f4a81e2a7766123bad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707ea08e31f44f4a81e2a7766123bad7">&#9670;&nbsp;</a></span>IPOINT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#ga707ea08e31f44f4a81e2a7766123bad7">IPOINT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines where the analysis call is inserted relative to the instrumented object. Instrumented object can be: INS, BBL, TRACE, RTN. This is used in instrumentation functions, for example see <a class="el" href="group__TRACE.html#gae5340cd88a962aac271e3547cdaa024e">TRACE_InsertCall()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga707ea08e31f44f4a81e2a7766123bad7a7c7cbebb7a62a40e9f803b1db2e6ce20"></a>IPOINT_BEFORE&#160;</td><td class="fielddoc"><p>Insert a call before the first instruction of the instrumented object. Always valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga707ea08e31f44f4a81e2a7766123bad7a42eff26179c6d87348abe492301c12ec"></a>IPOINT_AFTER&#160;</td><td class="fielddoc"><p>Insert a call on the fall-through path of the last instruction of the instrumented object (if such fall-through exists).<br />
 In case of a routine (RTN), instruments all return paths. Always valid.<br />
 In case of an instruction (INS), valid only if <a class="el" href="group__INS__INSPECTION.html#gaef208009ec86a213f7574b65fe2603c0">INS_IsValidForIpointAfter()</a> is true.<br />
 In case of a BBL, valid only if <a class="el" href="group__BBL.html#ga49b398eb9c10ff80019315d6c2eee84a">BBL_HasFallThrough()</a> is true.<br />
 In case of a TRACE, valid only if <a class="el" href="group__TRACE.html#ga2134ee647c01b25e4ad20cbbddce5ef1">TRACE_HasFallThrough()</a> is true.<br />
</p>
</td></tr>
<tr><td class="fieldname"><a id="gga707ea08e31f44f4a81e2a7766123bad7acf7dee2063098dd79907d19f9c7df65d"></a>IPOINT_ANYWHERE&#160;</td><td class="fielddoc"><p>Insert a call anywhere inside the instrumented object.<br />
 Valid on all instrumentation functions except <a class="el" href="group__INS__INSTRUMENTATION.html#ga3b589b45d857832458ca84ac5b6f04be">INS_InsertIfCall()</a>, <a class="el" href="group__INS__INSTRUMENTATION.html#gaf88934525048d52d54a76f02d1ec3cf0">INS_InsertThenCall()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga707ea08e31f44f4a81e2a7766123bad7a5ef5b45901a8447e5173f50746ab029d"></a>IPOINT_TAKEN_BRANCH&#160;</td><td class="fielddoc"><p>Insert a call on the taken edge of control-flow instructions of the instrumented object.<br />
 In case of an instruction, Valid only if <a class="el" href="group__INS__INSPECTION.html#gab13f78210172b7647bf5979b4e7f764f">INS_IsValidForIpointTakenBranch()</a> is true. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga624ddd00f45938da5eb525afc5b43195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga624ddd00f45938da5eb525afc5b43195">&#9670;&nbsp;</a></span>PIN_MEMOP_ENUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#ga624ddd00f45938da5eb525afc5b43195">PIN_MEMOP_ENUM</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>used in the Type whose address is passed to analysis routine when IARG_MULTI_MEMORYACCESS_EA is requested </p>

</div>
</div>
<a id="ga16b7ac266c4c1323b18396be70279eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b7ac266c4c1323b18396be70279eb0">&#9670;&nbsp;</a></span>PIN_OP_ELEMENT_ACCESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__INST__ARGS.html#ga16b7ac266c4c1323b18396be70279eb0">PIN_OP_ELEMENT_ACCESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Element Access type used in <a class="el" href="classIMULTI__ELEMENT__OPERAND.html">IMULTI_ELEMENT_OPERAND</a> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga85838e12fe04880ed61c5c60378c0147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85838e12fe04880ed61c5c60378c0147">&#9670;&nbsp;</a></span>IARGLIST_AddArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID IARGLIST_AddArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a>&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an argument to an IARGLIST.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga3d3e1e48b6fe3d71cb9f04a202ac55d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d3e1e48b6fe3d71cb9f04a202ac55d7">&#9670;&nbsp;</a></span>IARGLIST_Alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a> IARGLIST_Alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a container to hold instrumentation arguments. Pass to *_InsertCall by using IARG_LIST</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a id="ga30472edf4c557377c7f6bc73601d0a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30472edf4c557377c7f6bc73601d0a90">&#9670;&nbsp;</a></span>IARGLIST_Free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID IARGLIST_Free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__INST__ARGS.html#gafbeb707dc23c7c09e1e8c932649107d5">IARGLIST</a>&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a container to hold instrumentation arguments. Pass to *_InsertCall by using IARG_LIST</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br />
<b>O/S</b>: Linux, Windows &amp; macOS*<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
