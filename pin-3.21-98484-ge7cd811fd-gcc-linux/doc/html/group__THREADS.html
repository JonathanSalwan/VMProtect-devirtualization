<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: Pin Thread API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Pin Thread API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga08319cb7eb56ee92a74dd9a97476c1eb"><td class="memItemLeft" align="right" valign="top">typedef INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a></td></tr>
<tr class="separator:ga08319cb7eb56ee92a74dd9a97476c1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645289be59039349ad77ad2fa7b0e2f3"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a></td></tr>
<tr class="separator:ga645289be59039349ad77ad2fa7b0e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga057233f26b54f23b1ddb0c0c5e31dba9"><td class="memItemLeft" align="right" valign="top">typedef UINT64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a></td></tr>
<tr class="separator:ga057233f26b54f23b1ddb0c0c5e31dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9cdcd6c1baf15e17c2eb305a16e25e"><td class="memItemLeft" align="right" valign="top">typedef NATIVE_TID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a></td></tr>
<tr class="separator:ga1c9cdcd6c1baf15e17c2eb305a16e25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7d4b7206749ac3075b941a513d876c5"><td class="memItemLeft" align="right" valign="top">typedef VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a>(VOID *arg)</td></tr>
<tr class="separator:gaf7d4b7206749ac3075b941a513d876c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf6029042d57fb825536c795c94d1ed"><td class="memItemLeft" align="right" valign="top">typedef UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga2bf6029042d57fb825536c795c94d1ed">OS_PROCESS_ID</a></td></tr>
<tr class="separator:ga2bf6029042d57fb825536c795c94d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>TLS_KEY_INTERNAL_EXCEPTION</b>, 
<br />
&#160;&#160;<b>TLS_KEY_CLIENT_FIRST</b>, 
<br />
&#160;&#160;<b>TLS_KEY_CLIENT_LAST</b> = TLS_KEY_CLIENT_FIRST + 63
<br />
 }</td></tr>
<tr class="separator:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0cb7ee1fcfd3c37ab61e5cce86a60bb0"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga0cb7ee1fcfd3c37ab61e5cce86a60bb0">PIN_SpawnApplicationThread</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt)</td></tr>
<tr class="separator:ga0cb7ee1fcfd3c37ab61e5cce86a60bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86826797380b83015d91b08d74e77f20"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga86826797380b83015d91b08d74e77f20">PIN_StopApplicationThreads</a> (<a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>
<tr class="separator:ga86826797380b83015d91b08d74e77f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad50e1fd43eddabc5ecebc94a2e7ff1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga2ad50e1fd43eddabc5ecebc94a2e7ff1">PIN_IsThreadStoppedInDebugger</a> (<a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>
<tr class="separator:ga2ad50e1fd43eddabc5ecebc94a2e7ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49e352a082b01080241542eb52aef06b"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga49e352a082b01080241542eb52aef06b">PIN_ResumeApplicationThreads</a> (<a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>
<tr class="separator:ga49e352a082b01080241542eb52aef06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e27a968025d489bf756008e847f66fc"><td class="memItemLeft" align="right" valign="top">UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga6e27a968025d489bf756008e847f66fc">PIN_GetStoppedThreadCount</a> ()</td></tr>
<tr class="separator:ga6e27a968025d489bf756008e847f66fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576c8a1cb5ad99011e7dc29d6e07e8e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga576c8a1cb5ad99011e7dc29d6e07e8e3">PIN_GetStoppedThreadId</a> (UINT32 i)</td></tr>
<tr class="separator:ga576c8a1cb5ad99011e7dc29d6e07e8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d2d7426185b7b561e1c9928e980275"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga87d2d7426185b7b561e1c9928e980275">PIN_GetStoppedThreadContext</a> (<a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>
<tr class="separator:ga87d2d7426185b7b561e1c9928e980275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d16d98c1a90acae42e0f20890b9b882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga6d16d98c1a90acae42e0f20890b9b882">PIN_GetStoppedThreadWriteableContext</a> (<a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid)</td></tr>
<tr class="separator:ga6d16d98c1a90acae42e0f20890b9b882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7957bec5714228e311e6f707fe3e18ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga7957bec5714228e311e6f707fe3e18ff">PIN_GetTid</a> ()</td></tr>
<tr class="separator:ga7957bec5714228e311e6f707fe3e18ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe759ff297488936fd2ad6d37eb60670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gabe759ff297488936fd2ad6d37eb60670">PIN_ThreadId</a> ()</td></tr>
<tr class="separator:gabe759ff297488936fd2ad6d37eb60670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5307c663b86d8ba41b564e8de4a8bab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga5307c663b86d8ba41b564e8de4a8bab8">PIN_ThreadUid</a> ()</td></tr>
<tr class="separator:ga5307c663b86d8ba41b564e8de4a8bab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ea27e2df9c1d42ec9d256577ecfb7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga78ea27e2df9c1d42ec9d256577ecfb7f">PIN_GetParentTid</a> ()</td></tr>
<tr class="separator:ga78ea27e2df9c1d42ec9d256577ecfb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48b46689c5449e5256e2157107f30fa5"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga48b46689c5449e5256e2157107f30fa5">PIN_Sleep</a> (UINT32 milliseconds)</td></tr>
<tr class="separator:ga48b46689c5449e5256e2157107f30fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dfa7f2e5da6935d8bb0b369d76a3681"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga8dfa7f2e5da6935d8bb0b369d76a3681">PIN_Yield</a> ()</td></tr>
<tr class="separator:ga8dfa7f2e5da6935d8bb0b369d76a3681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23fe7ae94deab5bf574ff601d3d85a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga23fe7ae94deab5bf574ff601d3d85a6b">PIN_SpawnInternalThread</a> (<a class="el" href="group__THREADS.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a> *pThreadFunc, VOID *arg, size_t stackSize, <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> *pThreadUid)</td></tr>
<tr class="separator:ga23fe7ae94deab5bf574ff601d3d85a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec484eccc13fd52c6c41ff663c6afbcc"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gaec484eccc13fd52c6c41ff663c6afbcc">PIN_ExitThread</a> (INT32 exitCode)</td></tr>
<tr class="separator:gaec484eccc13fd52c6c41ff663c6afbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b23785020a1f4666f9980805abc7aa4"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga2b23785020a1f4666f9980805abc7aa4">PIN_IsApplicationThread</a> ()</td></tr>
<tr class="separator:ga2b23785020a1f4666f9980805abc7aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd0dc2709292f807cb233e5ec0f809a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gaddd0dc2709292f807cb233e5ec0f809a">PIN_WaitForThreadTermination</a> (const <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &amp;threadUid, UINT32 milliseconds, INT32 *pExitCode)</td></tr>
<tr class="separator:gaddd0dc2709292f807cb233e5ec0f809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90ea83ef63975cdbd767d3cc68f80cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gad90ea83ef63975cdbd767d3cc68f80cd">PIN_CreateThreadDataKey</a> (DESTRUCTFUN destruct_func)</td></tr>
<tr class="separator:gad90ea83ef63975cdbd767d3cc68f80cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac708db5e650bd8bea16364453d79d896"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gac708db5e650bd8bea16364453d79d896">PIN_DeleteThreadDataKey</a> (<a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a> key)</td></tr>
<tr class="separator:gac708db5e650bd8bea16364453d79d896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43216c2d5e64dc66a1a5c02821ee2877"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga43216c2d5e64dc66a1a5c02821ee2877">PIN_SetThreadData</a> (<a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a> key, const VOID *data, <a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadId)</td></tr>
<tr class="separator:ga43216c2d5e64dc66a1a5c02821ee2877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf179edfddb0b623e41d84d954a32dbc0"><td class="memItemLeft" align="right" valign="top">VOID *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gaf179edfddb0b623e41d84d954a32dbc0">PIN_GetThreadData</a> (<a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a> key, <a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> threadId)</td></tr>
<tr class="separator:gaf179edfddb0b623e41d84d954a32dbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac20e94689fb8467e0309ed7bc0410654"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gac20e94689fb8467e0309ed7bc0410654">INVALID_TLS_KEY</a> = (-1)</td></tr>
<tr class="separator:gac20e94689fb8467e0309ed7bc0410654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0cadbcbcfe2cc7825893c8f228317c"><td class="memItemLeft" align="right" valign="top">const UINT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gafa0cadbcbcfe2cc7825893c8f228317c">MAX_CLIENT_TLS_KEYS</a> = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td></tr>
<tr class="separator:gafa0cadbcbcfe2cc7825893c8f228317c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f1b19d7792c8c6f4547fd9d3dabb427"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#ga6f1b19d7792c8c6f4547fd9d3dabb427">INVALID_THREADID</a> = static_cast&lt; <a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> &gt;(-1)</td></tr>
<tr class="separator:ga6f1b19d7792c8c6f4547fd9d3dabb427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea3bf4ebf6808cbc830c0735c9285ad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gadea3bf4ebf6808cbc830c0735c9285ad">INVALID_PIN_THREAD_UID</a> = static_cast&lt; <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &gt;(-1)</td></tr>
<tr class="separator:gadea3bf4ebf6808cbc830c0735c9285ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb51a301378b609eaeffa48de3355945"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__THREADS.html#gafb51a301378b609eaeffa48de3355945">INVALID_OS_THREAD_ID</a> = INVALID_NATIVE_TID</td></tr>
<tr class="separator:gafb51a301378b609eaeffa48de3355945"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2bf6029042d57fb825536c795c94d1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf6029042d57fb825536c795c94d1ed">&#9670;&nbsp;</a></span>OS_PROCESS_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__THREADS.html#ga2bf6029042d57fb825536c795c94d1ed">OS_PROCESS_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process ID assigned by OS. </p>

</div>
</div>
<a id="ga1c9cdcd6c1baf15e17c2eb305a16e25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c9cdcd6c1baf15e17c2eb305a16e25e">&#9670;&nbsp;</a></span>OS_THREAD_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NATIVE_TID <a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread ID assigned by OS. </p>

</div>
</div>
<a id="ga057233f26b54f23b1ddb0c0c5e31dba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga057233f26b54f23b1ddb0c0c5e31dba9">&#9670;&nbsp;</a></span>PIN_THREAD_UID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT64 <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unique thread ID which, unlike THREADID identifier, is not reused by Pin after the thread termination. The uniqueness of this identifier allows to use it in the <a class="el" href="group__THREADS.html#gaddd0dc2709292f807cb233e5ec0f809a">PIN_WaitForThreadTermination()</a> function which monitors the thread's state. </p>

</div>
</div>
<a id="gaf7d4b7206749ac3075b941a513d876c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7d4b7206749ac3075b941a513d876c5">&#9670;&nbsp;</a></span>ROOT_THREAD_FUNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VOID ROOT_THREAD_FUNC(VOID *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main (starting) function of a thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of the main thread function, as specified by the thread creator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga645289be59039349ad77ad2fa7b0e2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga645289be59039349ad77ad2fa7b0e2f3">&#9670;&nbsp;</a></span>THREADID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UINT32 <a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread ID assigned by PIN. </p>

</div>
</div>
<a id="ga08319cb7eb56ee92a74dd9a97476c1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08319cb7eb56ee92a74dd9a97476c1eb">&#9670;&nbsp;</a></span>TLS_KEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef INT32 <a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type that represents TLS key - a unique identifier of a slot in the thread local storage. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga06fc87d81c62e9abb8790b6e5713c55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06fc87d81c62e9abb8790b6e5713c55b">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keys to access client data in the thread local storage </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad90ea83ef63975cdbd767d3cc68f80cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad90ea83ef63975cdbd767d3cc68f80cd">&#9670;&nbsp;</a></span>PIN_CreateThreadDataKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a> PIN_CreateThreadDataKey </td>
          <td>(</td>
          <td class="paramtype">DESTRUCTFUN&#160;</td>
          <td class="paramname"><em>destruct_func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new TLS key and associate it with a given data destruction function. Upon successful return, any thread of the process can use <a class="el" href="group__DEPRECATED.html#ga83442cefc4872a7a1ef65dcd8d7a5212">PIN_SetThreadData()</a> and <a class="el" href="group__DEPRECATED.html#ga61a18ab0c0480233459762b242fe1f5a">PIN_GetThreadData()</a> functions to store and retrieve values in its own slot, referenced by the allocated key. The initial value associated with the key in all threads is NULL. At the thread exit, if a key has a non-NULL pointer to the cleanup (destruction) function, and the thread has a non-NULL value in the corresponding slot, the function is called with the slot's value as its sole argument. The order in which destructors are invoked is undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destructFun</td><td>optional parameter that specifies data destruction function to be associated with the new key. This function is called just after notifying the client about VM thread exit. By default (NULL destructor), the data is not cleaned up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated TLS key, upon success; -1, if number of already allocated keys reached the MAX_CLIENT_TLS_KEYS limit.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="gac708db5e650bd8bea16364453d79d896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac708db5e650bd8bea16364453d79d896">&#9670;&nbsp;</a></span>PIN_DeleteThreadDataKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_DeleteThreadDataKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release TLS key, allocated by a previous call to the <a class="el" href="group__THREADS.html#gad90ea83ef63975cdbd767d3cc68f80cd">PIN_CreateThreadDataKey()</a> function. The function has no effect if specified key is not allocated/already released. After the key is released, a client should not attempt to use it for any further TLS access. Doing otherwise results in undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key to be released </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, upon success; FALSE, if if specified key is invalid</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="gaec484eccc13fd52c6c41ff663c6afbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec484eccc13fd52c6c41ff663c6afbcc">&#9670;&nbsp;</a></span>PIN_ExitThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_ExitThread </td>
          <td>(</td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>exitCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminate the current thread.</p>
<p>This function is intended for threads created by the tool (see <a class="el" href="group__THREADS.html#ga23fe7ae94deab5bf574ff601d3d85a6b">PIN_SpawnInternalThread()</a>) and is not normally used for threads created by the application, since application threads exit automatically when Pin executes a thread termination system call on their behalf.</p>
<p>If this call is made on an application thread, Pin will make any callbacks registered for thread exit before the thread is terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">exitCode</td><td>exit code of the thread to be returned by the <a class="el" href="group__THREADS.html#gaddd0dc2709292f807cb233e5ec0f809a">PIN_WaitForThreadTermination()</a> function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the function never returns.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga78ea27e2df9c1d42ec9d256577ecfb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ea27e2df9c1d42ec9d256577ecfb7f">&#9670;&nbsp;</a></span>PIN_GetParentTid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a> PIN_GetParentTid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get system identifier of the parent thread, if known. </p><dl class="section return"><dt>Returns</dt><dd>system ID of the parent thread or INVALID_OS_THREAD_ID if the parent thread is unknown. On Windows the result is always INVALID_OS_THREAD_ID, since there is, in general, no well defined parent child relationship between threads.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga87d2d7426185b7b561e1c9928e980275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87d2d7426185b7b561e1c9928e980275">&#9670;&nbsp;</a></span>PIN_GetStoppedThreadContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structCONTEXT.html">CONTEXT</a>* PIN_GetStoppedThreadContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the <a class="el" href="structCONTEXT.html">CONTEXT</a> (register state) of a stopped application thread. The caller can inspect the stopped thread's register state via <a class="el" href="group__CONTEXT.html#ga5b5aea73f92ac62e0767cb32bf8de4ed">PIN_GetContextReg()</a> and related API's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Pin ID of a stopped thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structCONTEXT.html">CONTEXT</a> for thread <em>tid</em> or NULL if that thread is not stopped.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga6e27a968025d489bf756008e847f66fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e27a968025d489bf756008e847f66fc">&#9670;&nbsp;</a></span>PIN_GetStoppedThreadCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UINT32 PIN_GetStoppedThreadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called in two scenarios. First, it may be called after stopping threads with <a class="el" href="group__THREADS.html#ga86826797380b83015d91b08d74e77f20">PIN_StopApplicationThreads()</a>, in which case it tells the number of application threads that were stopped with that API.</p>
<p>Alternatively, this function may be called from a call-back that is registered via <a class="el" href="group__APPDEBUG.html#ga8b7429dba7db028dc095a48d026b30f3">PIN_AddDebugInterpreter()</a>. In this case, it tells the number of application threads that are stopped in the debugger.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of stopped application threads. Returns zero if threads are not currently stopped.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga576c8a1cb5ad99011e7dc29d6e07e8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga576c8a1cb5ad99011e7dc29d6e07e8e3">&#9670;&nbsp;</a></span>PIN_GetStoppedThreadId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> PIN_GetStoppedThreadId </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the Pin thread ID of a stopped application thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>An index in the range [0, n-1], where <em>n</em> is the value returned by <a class="el" href="group__THREADS.html#ga6e27a968025d489bf756008e847f66fc">PIN_GetStoppedThreadCount()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The ID of the indexed thread, which is currently stopped. Returns INVALID_THREADID if <em>i</em> is out of range.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga6d16d98c1a90acae42e0f20890b9b882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d16d98c1a90acae42e0f20890b9b882">&#9670;&nbsp;</a></span>PIN_GetStoppedThreadWriteableContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCONTEXT.html">CONTEXT</a>* PIN_GetStoppedThreadWriteableContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to <a class="el" href="group__THREADS.html#ga87d2d7426185b7b561e1c9928e980275">PIN_GetStoppedThreadContext()</a>, but it returns a <a class="el" href="structCONTEXT.html">CONTEXT</a> that may be modified. The caller may modify the stopped thread's register state via <a class="el" href="group__CONTEXT.html#ga83c0549f92440cf717c08689c47127cd">PIN_SetContextReg()</a> and related API's. The stopped thread uses the new register state when it resumes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>Pin ID of a stopped thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="structCONTEXT.html">CONTEXT</a> for thread <em>tid</em> or NULL if that thread is not stopped.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="gaf179edfddb0b623e41d84d954a32dbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf179edfddb0b623e41d84d954a32dbc0">&#9670;&nbsp;</a></span>PIN_GetThreadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID* PIN_GetThreadData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value stored in the specified TLS slot of the thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key, referencing the slot, whose value is requested. The key should be allocated by a previous call to the <a class="el" href="group__THREADS.html#gad90ea83ef63975cdbd767d3cc68f80cd">PIN_CreateThreadDataKey()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <a class="el" href="group__THREADS.html#gabe759ff297488936fd2ad6d37eb60670">PIN_ThreadId()</a> function call or received as the value of the IARG_THREAD_ID argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value stored in the specified slot of the thread, if specified key is currently allocated; NULL, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga7957bec5714228e311e6f707fe3e18ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7957bec5714228e311e6f707fe3e18ff">&#9670;&nbsp;</a></span>PIN_GetTid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a> PIN_GetTid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Threading API for clients</p>
<p>Get system identifier of the current thread. </p><dl class="section return"><dt>Returns</dt><dd>system ID of the current thread.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga2b23785020a1f4666f9980805abc7aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b23785020a1f4666f9980805abc7aa4">&#9670;&nbsp;</a></span>PIN_IsApplicationThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_IsApplicationThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the current thread is created by the application or it is an internal thread spawned by the tool or Pin itself (see <a class="el" href="group__THREADS.html#ga23fe7ae94deab5bf574ff601d3d85a6b">PIN_SpawnInternalThread()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if this function is called in a thread created by the application; FALSE, if this function is called in an internal thread spawned by the tool or Pin.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga2ad50e1fd43eddabc5ecebc94a2e7ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad50e1fd43eddabc5ecebc94a2e7ff1">&#9670;&nbsp;</a></span>PIN_IsThreadStoppedInDebugger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_IsThreadStoppedInDebugger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns true if the thread with denoted by 'tid' given by its arguments was stopped in the debugger. Note: If there is no thread with ID 'tid', this function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The Pin thread ID to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the specified thread was stopped in the debugger. FALSE indicates that the thread is either running, or doesn't exist</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga49e352a082b01080241542eb52aef06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49e352a082b01080241542eb52aef06b">&#9670;&nbsp;</a></span>PIN_ResumeApplicationThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_ResumeApplicationThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function may be called after a successful call to <a class="el" href="group__THREADS.html#ga86826797380b83015d91b08d74e77f20">PIN_StopApplicationThreads()</a> in order to resume execution of the stopped application threads. If a thread's <a class="el" href="structCONTEXT.html">CONTEXT</a> was changed while it was stopped, it resumes with the new <a class="el" href="structCONTEXT.html">CONTEXT</a>.</p>
<p>@Note When used in application thread, it is highly recommended to call it in the same analysis function that called <a class="el" href="group__THREADS.html#ga86826797380b83015d91b08d74e77f20">PIN_StopApplicationThreads()</a>. Deferring the call could result in a deadlock when the thread later tries to acquire a lock held by other application thread it suspended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The Pin thread ID of the calling thread. Should be called in the same thread as corresponding <a class="el" href="group__THREADS.html#ga86826797380b83015d91b08d74e77f20">PIN_StopApplicationThreads()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga43216c2d5e64dc66a1a5c02821ee2877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43216c2d5e64dc66a1a5c02821ee2877">&#9670;&nbsp;</a></span>PIN_SetThreadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_SetThreadData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VOID *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>threadId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store specified value in the specified TLS slot of the thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>TLS key, referencing the slot, where the value will be stored upon successful return. The key should be allocated by a previous call to the <a class="el" href="group__THREADS.html#gad90ea83ef63975cdbd767d3cc68f80cd">PIN_CreateThreadDataKey()</a> function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>value to be stored in the TLS slot of the current thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadId</td><td>Thread ID assigned by pin of the thread for which TLS access is desired, not necessarily the current thread. This ID can be obtained by the <a class="el" href="group__THREADS.html#gabe759ff297488936fd2ad6d37eb60670">PIN_ThreadId()</a> function call or received as the value of the IARG_THREAD_ID argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE, if specified key is currently allocated; FALSE, if specified key is invalid or the given thread is not yet registered in the pin thread database; undefined, if specified key is valid, but it is not currently allocated</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga48b46689c5449e5256e2157107f30fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48b46689c5449e5256e2157107f30fa5">&#9670;&nbsp;</a></span>PIN_Sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_Sleep </td>
          <td>(</td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay execution of the current thread for the specified time interval. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>time interval, in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga0cb7ee1fcfd3c37ab61e5cce86a60bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cb7ee1fcfd3c37ab61e5cce86a60bb0">&#9670;&nbsp;</a></span>PIN_SpawnApplicationThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_SpawnApplicationThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start a new thread which will begin to execute with the register state from the context. At least the flags register in the context must be sensible (even if all of the thread's registers will be set in the thread start callback).</p>
<p>This function requires the VM lock to operate, so will acquire and release it if it is not already held.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context for the new thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a new thread was sucessfully spawned, FALSE if not.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API. </dd>
<dd>
This function must be used on applications that are running with the (newer) NPTL version of pthread library. Running this function on an application that is running with the (older) LinuxThreads version of pthread can prevent PIN from shuting down the VM when the application exits.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga23fe7ae94deab5bf574ff601d3d85a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23fe7ae94deab5bf574ff601d3d85a6b">&#9670;&nbsp;</a></span>PIN_SpawnInternalThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> PIN_SpawnInternalThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#gaf7d4b7206749ac3075b941a513d876c5">ROOT_THREAD_FUNC</a> *&#160;</td>
          <td class="paramname"><em>pThreadFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VOID *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> *&#160;</td>
          <td class="paramname"><em>pThreadUid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new tool internal thread in the current process.</p>
<p>It is safe to create internal threads in the tool's main procedure and spawn new internal threads from existing ones. However new internal threads cannot be created in any other places, like Pin callbacks and analysis routines in application threads.<br  />
 In order to ensure graceful termination of internal threads on the application's exit, the tool can use the following recommended method:</p><ul>
<li>The tool uses the <a class="el" href="group__PIN__CONTROL.html#gacd670ecd04074a3962968de22aab247c">PIN_AddPrepareForFiniFunction()</a> function to register a <a class="el" href="group__PIN__CONTROL.html#ga47618aec52f2e6918ca0ffce8fefabde">PREPARE_FOR_FINI_CALLBACK</a> callback. When the registered function is called in an "unlocked" thread, the tool requests each other internal thread to exit and waits until the <a class="el" href="group__THREADS.html#gaddd0dc2709292f807cb233e5ec0f809a">PIN_WaitForThreadTermination()</a> function returns. @Note: Pin doesn't wait for internal threads termination after the callbacks.</li>
</ul>
<p>Many of Pin's APIs, that are primarily intended for application threads, are also available in internal threads. Look at the API's description ( <b>Availability</b> paragraph) or the description of the corresponding group of APIs to check whether a specific API is available in internal threads.<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pThreadFunc</td><td>main (starting) function of the thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of the main thread function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stackSize</td><td>size of the thread's stack, in bytes. The function rounds this value up to the page size. If this parameter is zero, DEFAULT_THREAD_STACK_SIZE bytes will be allocated for the stack. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pThreadUid</td><td>pointer to a variable that receives the unique identifier of the new thread in Pin. This identifier can be used in the <a class="el" href="group__THREADS.html#gaddd0dc2709292f807cb233e5ec0f809a">PIN_WaitForThreadTermination()</a> function to monitor the thread's state. If the caller specifies NULL for this parameter, the unique thread ID is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID of the new thread in Pin or INVALID_THREADID if the thread creation failed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__THREADS.html#ga23fe7ae94deab5bf574ff601d3d85a6b">PIN_SpawnInternalThread()</a> API is the only way for tools to create a private thread in the Pin-controlled process. System services, like CreateThread() in Windows or clone() in Linux should not be used for this purpose. </dd></dl>
<dl class="section user"><dt></dt><dd>Pin makes an effort to hide internal threads from the application so, usually, a tool's threads do not interfere with the application. However, the complete transparency of internal threads is not guaranteed, so tools should only use them when their instrumentation tasks cannot be done (effectively) by analysis routines within application threads. For example, a need to execute Windows services (Win32 APIs) may be a reason for creating a private thread in the tool. All Win32 APIs that do not modify the application's resources can be freely used in internal threads. In application threads, on the contrary, using Win32 APIs in analysis routines and Pin callbacks is not supported due to possible reentrancy and isolation problems. </dd></dl>
<dl class="section user"><dt></dt><dd>Internal threads remain blocked inside Pin until <a class="el" href="group__PIN__CONTROL.html#gab466cd00518ff315446c92f98f7ea1a0">PIN_StartProgram()</a> is called and Pin completes some initialization. On Linux, internal threads start running <em>pThreadFunc</em> before Pin executes the first application instruction. On Windows all threads, including Pin internal threads, start executing from the system runtime before they execute the <em>pThreadFunc</em> function. However, the system runtime blocks threads until the application has finished initializing its DLL's (i.e. until the application releases the internal "loader lock"). As a result, Pin internal threads on Windows do not execute <em>pThreadFunc</em> until after the application finishes executing the DLL initialization code. On macOS* in launch mode internal threads start running <em>pThreadFun</em> only after the application loader initialize the main executable. Hence don't expect the internal thread to start running after calling this function from the tool main() function in launch mode.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows, macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga86826797380b83015d91b08d74e77f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86826797380b83015d91b08d74e77f20">&#9670;&nbsp;</a></span>PIN_StopApplicationThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_StopApplicationThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pin client functions to temporarily stop all application threads, examine their state and resume.</p>
<p>This function may be called by either an application thread or by a Pin internal thread to stop all other application threads at a "safe point". Threads that are stopped at a safe point are always stopped in between traces, so the caller is guaranteed that they are not stopped in the middle of any analysis functions or call-back functions. Once stopped, the calling thread can examine and modify the registers of the stopped threads.</p>
<p>If this function is called by an internal thread, it stops all application threads. If it is called by an application thread, it stops all other application threads. When called by an application thread, this function may be called from an analysis function, but not from a call-back function.</p>
<p>Since this function blocks until other application threads finish their current trace, the caller must not hold any locks that the other threads might try to acquire. Doing so could result in a deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The Pin thread ID of the calling thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the target threads are successfully stopped. FALSE indicates that some other thread is trying to stop the calling thread. In such a case, the caller should return from its analysis function to avoid a deadlock.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="gabe759ff297488936fd2ad6d37eb60670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe759ff297488936fd2ad6d37eb60670">&#9670;&nbsp;</a></span>PIN_ThreadId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> PIN_ThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get identifier of the current thread in Pin. </p><dl class="section return"><dt>Returns</dt><dd>ID of the current thread in Pin or INVALID_THREADID upon failure. Usually, the failure means that the function is called in a private tool's thread which is created by a direct call to a system service and not via the <a class="el" href="group__THREADS.html#ga23fe7ae94deab5bf574ff601d3d85a6b">PIN_SpawnInternalThread()</a> function.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga5307c663b86d8ba41b564e8de4a8bab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5307c663b86d8ba41b564e8de4a8bab8">&#9670;&nbsp;</a></span>PIN_ThreadUid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> PIN_ThreadUid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get unique identifier of the current thread in Pin. </p><dl class="section return"><dt>Returns</dt><dd>Unique ID of the current thread in Pin or INVALID_PIN_THREAD_UID upon failure. Usually, the failure means that the function is called in a private tool's thread which is created by a direct call to a system service and not via the <a class="el" href="group__THREADS.html#ga23fe7ae94deab5bf574ff601d3d85a6b">PIN_SpawnInternalThread()</a> function.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="gaddd0dc2709292f807cb233e5ec0f809a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddd0dc2709292f807cb233e5ec0f809a">&#9670;&nbsp;</a></span>PIN_WaitForThreadTermination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_WaitForThreadTermination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &amp;&#160;</td>
          <td class="paramname"><em>threadUid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT32&#160;</td>
          <td class="paramname"><em>milliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32 *&#160;</td>
          <td class="paramname"><em>pExitCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delay the current thread until the specified thread is terminated or the time-out interval elapses.</p>
<p>To avoid deadlocks, the caller should not hold any lock that the target thread may try to acquire. For example, this function can be safely used in the <a class="el" href="group__PIN__CONTROL.html#ga47618aec52f2e6918ca0ffce8fefabde">PREPARE_FOR_FINI_CALLBACK</a> callback if it is registered by the <a class="el" href="group__PIN__CONTROL.html#gacd670ecd04074a3962968de22aab247c">PIN_AddPrepareForFiniFunction()</a>. However, it is not recommended to use this function in other Pin callbacks if the target thread is an application thread or an internal thread that uses Pin APIs. This is because most of Pin APIs and callbacks are serialized by the same internal lock.<br  />
 This function can not be used to wait for the termination of the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadUid</td><td>unique identifier of the thread to be waited for termination, provided by <a class="el" href="group__THREADS.html#ga23fe7ae94deab5bf574ff601d3d85a6b">PIN_SpawnInternalThread()</a> or <a class="el" href="group__THREADS.html#ga5307c663b86d8ba41b564e8de4a8bab8">PIN_ThreadUid()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">milliseconds</td><td>time-out interval, in milliseconds. If this parameter is zero, the function tests the thread's state and returns immediately. If this parameter is PIN_INFINITE_TIMEOUT, the time-out interval never elapses. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pExitCode</td><td>optional pointer to a variable that receives exit code of the thread. If this pointer is NULL or the thread has not terminated, the exit code is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE - the thread has terminated, FALSE - the specified time-out interval elapsed or threadUid is not valid or corresponds to current thread or specified thread is not yet started when application shutdown begins.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<a id="ga8dfa7f2e5da6935d8bb0b369d76a3681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dfa7f2e5da6935d8bb0b369d76a3681">&#9670;&nbsp;</a></span>PIN_Yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_Yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Yield the processor to another thread.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT &amp; Probe<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> All<br  />
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gafb51a301378b609eaeffa48de3355945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb51a301378b609eaeffa48de3355945">&#9670;&nbsp;</a></span>INVALID_OS_THREAD_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__THREADS.html#ga1c9cdcd6c1baf15e17c2eb305a16e25e">OS_THREAD_ID</a> INVALID_OS_THREAD_ID = INVALID_NATIVE_TID</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the OS_THREAD_ID type. </p>

</div>
</div>
<a id="gadea3bf4ebf6808cbc830c0735c9285ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadea3bf4ebf6808cbc830c0735c9285ad">&#9670;&nbsp;</a></span>INVALID_PIN_THREAD_UID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> INVALID_PIN_THREAD_UID = static_cast&lt; <a class="el" href="group__THREADS.html#ga057233f26b54f23b1ddb0c0c5e31dba9">PIN_THREAD_UID</a> &gt;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the PIN_THREAD_UID type. </p>

</div>
</div>
<a id="ga6f1b19d7792c8c6f4547fd9d3dabb427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f1b19d7792c8c6f4547fd9d3dabb427">&#9670;&nbsp;</a></span>INVALID_THREADID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> INVALID_THREADID = static_cast&lt; <a class="el" href="group__THREADS.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> &gt;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the THREADID type. </p>

</div>
</div>
<a id="gac20e94689fb8467e0309ed7bc0410654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac20e94689fb8467e0309ed7bc0410654">&#9670;&nbsp;</a></span>INVALID_TLS_KEY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__THREADS.html#ga08319cb7eb56ee92a74dd9a97476c1eb">TLS_KEY</a> INVALID_TLS_KEY = (-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invalid value of the TLS_KEY type. </p>

</div>
</div>
<a id="gafa0cadbcbcfe2cc7825893c8f228317c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa0cadbcbcfe2cc7825893c8f228317c">&#9670;&nbsp;</a></span>MAX_CLIENT_TLS_KEYS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const UINT32 MAX_CLIENT_TLS_KEYS = (TLS_KEY_CLIENT_LAST - TLS_KEY_CLIENT_FIRST + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of TLS keys that can be allocated by tool </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
