<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pin: Context manipulation API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Context manipulation API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structXSAVE__HEADER.html">XSAVE_HEADER</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFPSTATE.html">FPSTATE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCONTEXT.html">CONTEXT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionPIN__WIDE__REGISTER.html">PIN_WIDE_REGISTER</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4ca557f14f098e2c733785a3a9a78f50"><td class="memItemLeft" align="right" valign="top">typedef UTIL::FXSAVE_IA32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga4ca557f14f098e2c733785a3a9a78f50">FXSAVE</a></td></tr>
<tr class="separator:ga4ca557f14f098e2c733785a3a9a78f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85506bdff3706d86277715a6542fd5a7"><td class="memItemLeft" align="right" valign="top">typedef UTIL::FXSAVE_INTEL64_DEFAULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga85506bdff3706d86277715a6542fd5a7">FXSAVE</a></td></tr>
<tr class="separator:ga85506bdff3706d86277715a6542fd5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f8f88949aaecf53a6d23f56399c676"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCONTEXT.html">CONTEXT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a></td></tr>
<tr class="separator:ga73f8f88949aaecf53a6d23f56399c676"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga479f2b92361e3794145bb90a1ea7e027"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a> { <br />
&#160;&#160;<a class="el" href="group__CONTEXT.html#gga479f2b92361e3794145bb90a1ea7e027a940f194773d13bfe7b71a589b3d6a29a">PROCESSOR_STATE_X87</a>, 
<br />
&#160;&#160;<a class="el" href="group__CONTEXT.html#gga479f2b92361e3794145bb90a1ea7e027ada893eda0a2fdd23742fb5d9f4ba25a7">PROCESSOR_STATE_XMM</a>, 
<br />
&#160;&#160;<a class="el" href="group__CONTEXT.html#gga479f2b92361e3794145bb90a1ea7e027a15481af1dfee3eb0845669e533b2d5e6">PROCESSOR_STATE_YMM</a>, 
<br />
&#160;&#160;<a class="el" href="group__CONTEXT.html#gga479f2b92361e3794145bb90a1ea7e027a32f9fcc0e7c055726930ee8d563ea248">PROCESSOR_STATE_ZMM</a>
<br />
 }</td></tr>
<tr class="separator:ga479f2b92361e3794145bb90a1ea7e027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga112f3ad5960ae4c2273c20abb6479b7a"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga112f3ad5960ae4c2273c20abb6479b7a">PIN_SupportsProcessorState</a> (<a class="el" href="group__CONTEXT.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a> state)</td></tr>
<tr class="separator:ga112f3ad5960ae4c2273c20abb6479b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd227ecb35493c392d80173180acd7c7"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gabd227ecb35493c392d80173180acd7c7">PIN_ContextContainsState</a> (<a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, <a class="el" href="group__CONTEXT.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a> state)</td></tr>
<tr class="separator:gabd227ecb35493c392d80173180acd7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae96c2fa413d6009f9775cfebab49912f"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gae96c2fa413d6009f9775cfebab49912f">PIN_SetContextRegval</a> (<a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, <a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a> reg, const UINT8 *val)</td></tr>
<tr class="separator:gae96c2fa413d6009f9775cfebab49912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f8eeba2b8b874087441df1c3a530e2"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga44f8eeba2b8b874087441df1c3a530e2">PIN_GetContextRegval</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, <a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a> reg, UINT8 *val)</td></tr>
<tr class="separator:ga44f8eeba2b8b874087441df1c3a530e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83c0549f92440cf717c08689c47127cd"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga83c0549f92440cf717c08689c47127cd">PIN_SetContextReg</a> (<a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, <a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a> reg, ADDRINT val)</td></tr>
<tr class="separator:ga83c0549f92440cf717c08689c47127cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5aea73f92ac62e0767cb32bf8de4ed"><td class="memItemLeft" align="right" valign="top">ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga5b5aea73f92ac62e0767cb32bf8de4ed">PIN_GetContextReg</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, <a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a> reg)</td></tr>
<tr class="separator:ga5b5aea73f92ac62e0767cb32bf8de4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147e92f2d15f95bd43cb6c8ea19057f4"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga147e92f2d15f95bd43cb6c8ea19057f4">PIN_SetContextFPState</a> (<a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, const <a class="el" href="structFPSTATE.html">FPSTATE</a> *fpstate)</td></tr>
<tr class="separator:ga147e92f2d15f95bd43cb6c8ea19057f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628d9e2f229dc5101142c94a5411d073"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga628d9e2f229dc5101142c94a5411d073">PIN_GetContextFPState</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, <a class="el" href="structFPSTATE.html">FPSTATE</a> *fpstate)</td></tr>
<tr class="separator:ga628d9e2f229dc5101142c94a5411d073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaac112366f778eedeb4b258a40558f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__REG.html#ga8a33ca031ce83cf24d58dca8adf19f6c">REGSET</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gacbaac112366f778eedeb4b258a40558f">PIN_GetFullContextRegsSet</a> ()</td></tr>
<tr class="separator:gacbaac112366f778eedeb4b258a40558f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0a55669ab303520f82e4f512e084f9"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gabd0a55669ab303520f82e4f512e084f9">PIN_SaveContext</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxtFrom, <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxtTo)</td></tr>
<tr class="separator:gabd0a55669ab303520f82e4f512e084f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2217c59d6e6b5cad08a59afe3d879a"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt)</td></tr>
<tr class="separator:gade2217c59d6e6b5cad08a59afe3d879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992f6073d146d7c5a61476f3a1ce474a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga992f6073d146d7c5a61476f3a1ce474a">PIN_GetInitialContextForUnwind</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, void *cursor)</td></tr>
<tr class="separator:ga992f6073d146d7c5a61476f3a1ce474a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e0232d7642468e8bfbd4eca00983ecf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga9e0232d7642468e8bfbd4eca00983ecf">PIN_Backtrace</a> (const <a class="el" href="structCONTEXT.html">CONTEXT</a> *ctxt, void **buffer, int size)</td></tr>
<tr class="separator:ga9e0232d7642468e8bfbd4eca00983ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad1b665d43ed8655d42cf86e474ceb5ea"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gad1b665d43ed8655d42cf86e474ceb5ea">VSTATE_PADDING</a> = 128</td></tr>
<tr class="separator:gad1b665d43ed8655d42cf86e474ceb5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf302a6d2cb4e89c0355540b1b0951d7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gaaf302a6d2cb4e89c0355540b1b0951d7">FPSTATE_SIZE</a> = sizeof(<a class="el" href="structFPSTATE.html">FPSTATE</a>)</td></tr>
<tr class="separator:gaaf302a6d2cb4e89c0355540b1b0951d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5ad5017cf79566f740ff72e37dfeec"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga0f5ad5017cf79566f740ff72e37dfeec">FPSTATE_ALIGNMENT</a> = 64</td></tr>
<tr class="separator:ga0f5ad5017cf79566f740ff72e37dfeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b665d43ed8655d42cf86e474ceb5ea"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gad1b665d43ed8655d42cf86e474ceb5ea">VSTATE_PADDING</a> = 128</td></tr>
<tr class="separator:gad1b665d43ed8655d42cf86e474ceb5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf302a6d2cb4e89c0355540b1b0951d7"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gaaf302a6d2cb4e89c0355540b1b0951d7">FPSTATE_SIZE</a> = sizeof(<a class="el" href="structFPSTATE.html">FPSTATE</a>)</td></tr>
<tr class="separator:gaaf302a6d2cb4e89c0355540b1b0951d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f5ad5017cf79566f740ff72e37dfeec"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga0f5ad5017cf79566f740ff72e37dfeec">FPSTATE_ALIGNMENT</a> = 64</td></tr>
<tr class="separator:ga0f5ad5017cf79566f740ff72e37dfeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eaa55c6615cdb2cc79394b9090c8024"><td class="memItemLeft" align="right" valign="top"><a id="ga9eaa55c6615cdb2cc79394b9090c8024"></a>
const ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_PHYSICAL_REGS</b> = REG_PHYSICAL_INTEGER_END - REG_PHYSICAL_INTEGER_BASE + 1</td></tr>
<tr class="separator:ga9eaa55c6615cdb2cc79394b9090c8024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6f76da4746595feeff8523343242ca"><td class="memItemLeft" align="right" valign="top"><a id="gaba6f76da4746595feeff8523343242ca"></a>
const ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><b>NUM_SCRATCH_REGS</b> = REG_INST_SCRATCH_LAST - <a class="el" href="group__REG.html#gga8f899d7ad1af070aae505a85cc998fa5ad593e48273d23890fe59832257fad44d">REG_INST_SCRATCH_BASE</a> + 1</td></tr>
<tr class="separator:gaba6f76da4746595feeff8523343242ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead9b5f2f3655bbaf2776ad99e2ad279"><td class="memItemLeft" align="right" valign="top">const ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gaead9b5f2f3655bbaf2776ad99e2ad279">NUM_SPECIAL_REGS</a> = 2 + NUM_SCRATCH_REGS</td></tr>
<tr class="separator:gaead9b5f2f3655bbaf2776ad99e2ad279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6031aa9d9115234b9c49c6d5ab6d9fa"><td class="memItemLeft" align="right" valign="top">const ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#gab6031aa9d9115234b9c49c6d5ab6d9fa">NUM_CONTEXT_INT_REGS</a> = NUM_PHYSICAL_REGS + <a class="el" href="group__CONTEXT.html#gaead9b5f2f3655bbaf2776ad99e2ad279">NUM_SPECIAL_REGS</a></td></tr>
<tr class="separator:gab6031aa9d9115234b9c49c6d5ab6d9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565196a3eaf9539660ef24845ca8c967"><td class="memItemLeft" align="right" valign="top">const ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga565196a3eaf9539660ef24845ca8c967">NUM_CONTEXT_REGS</a> = REG_LAST_CONTEXT_REG + 1</td></tr>
<tr class="separator:ga565196a3eaf9539660ef24845ca8c967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b5de856336b8d0452a63a746bb9c61"><td class="memItemLeft" align="right" valign="top">const ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga15b5de856336b8d0452a63a746bb9c61">ARCH_STATE_SIZE</a></td></tr>
<tr class="separator:ga15b5de856336b8d0452a63a746bb9c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63af62bca2c39be3fd6edd57ad2ac5c3"><td class="memItemLeft" align="right" valign="top">const ADDRINT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CONTEXT.html#ga63af62bca2c39be3fd6edd57ad2ac5c3">DEFAULT_CONTEXT_IMPL</a> = 0</td></tr>
<tr class="separator:ga63af62bca2c39be3fd6edd57ad2ac5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Usually, the tool receives context in the instrumentation callback like THREAD_START_CALLBACK, CONTEXT_CHANGE_CALLBACK, or when it specifies explicitly to pass <a class="el" href="structCONTEXT.html">CONTEXT</a> to the instrumentation routine via IARG_CONTEXT, IARG_CONST_CONTEXT or IARG_PARTIAL_CONTEXT. At this time, the tool can read the individual register value via <a class="el" href="group__CONTEXT.html#ga5b5aea73f92ac62e0767cb32bf8de4ed">PIN_GetContextReg</a> and @PIN_GetContextRegval, or save the entire context using the <a class="el" href="group__CONTEXT.html#gabd0a55669ab303520f82e4f512e084f9">PIN_SaveContext</a>. The <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a> function can be called from an analysis routine to change the control flow of the thread and start execution from the specified context. The <a class="el" href="group__CONTEXT.html#ga83c0549f92440cf717c08689c47127cd">PIN_SetContextReg</a> and <a class="el" href="group__CONTEXT.html#gae96c2fa413d6009f9775cfebab49912f">PIN_SetContextRegval</a> functions can be used from callbacks to change the thread's given register state. In case where <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> was used the behaviour of the threads can be changed by changing registers values without using the <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a>. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga73f8f88949aaecf53a6d23f56399c676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73f8f88949aaecf53a6d23f56399c676">&#9670;&nbsp;</a></span>CONTEXT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCONTEXT.html">CONTEXT</a> <a class="el" href="structCONTEXT.html">CONTEXT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Architectural state of the processor.<br  />
The tool should not read or modify data members of this structure directly, but must treat the structure as logically opaque and use the <a class="el" href="group__CONTEXT.html">Context manipulation API</a> functions to manage it. </p>

</div>
</div>
<a id="ga4ca557f14f098e2c733785a3a9a78f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ca557f14f098e2c733785a3a9a78f50">&#9670;&nbsp;</a></span>FXSAVE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UTIL::FXSAVE_IA32 <a class="el" href="group__CONTEXT.html#ga4ca557f14f098e2c733785a3a9a78f50">FXSAVE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contains declarations of types related to the fp state on ia-32</p>
<p>The memory layout written by FXSAVE and read by FXRSTOR. It is the legacy part of the FP state </p>

</div>
</div>
<a id="ga85506bdff3706d86277715a6542fd5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85506bdff3706d86277715a6542fd5a7">&#9670;&nbsp;</a></span>FXSAVE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef UTIL::FXSAVE_INTEL64_DEFAULT <a class="el" href="group__CONTEXT.html#ga4ca557f14f098e2c733785a3a9a78f50">FXSAVE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contains declarations of types related to the fp state on Intel64</p>
<p>The memory layout written by FXSAVE and read by FXRSTOR. It is the legacy part of the FP state </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga479f2b92361e3794145bb90a1ea7e027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga479f2b92361e3794145bb90a1ea7e027">&#9670;&nbsp;</a></span>PROCESSOR_STATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__CONTEXT.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enums for queries on the supported state: PIN_SupportsProcessorState and PIN_ContextContainsState </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027a940f194773d13bfe7b71a589b3d6a29a"></a>PROCESSOR_STATE_X87&#160;</td><td class="fielddoc"><p>is the X87 (fp stack) supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027ada893eda0a2fdd23742fb5d9f4ba25a7"></a>PROCESSOR_STATE_XMM&#160;</td><td class="fielddoc"><p>are the xmm registers supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027a15481af1dfee3eb0845669e533b2d5e6"></a>PROCESSOR_STATE_YMM&#160;</td><td class="fielddoc"><p>are the ymm registers supported </p>
</td></tr>
<tr><td class="fieldname"><a id="gga479f2b92361e3794145bb90a1ea7e027a32f9fcc0e7c055726930ee8d563ea248"></a>PROCESSOR_STATE_ZMM&#160;</td><td class="fielddoc"><p>are the zmm registers supported </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9e0232d7642468e8bfbd4eca00983ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e0232d7642468e8bfbd4eca00983ecf">&#9670;&nbsp;</a></span>PIN_Backtrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PIN_Backtrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the equivalent Pin version of backtrace(): While backtrace() generates a backtrace for the Pin (and Pin tool) call stack, <a class="el" href="group__CONTEXT.html#ga9e0232d7642468e8bfbd4eca00983ecf">PIN_Backtrace()</a> generates a backtrace for the application that Pin is instrumenting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context of the application - the backtrace will be generated based upon it. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Points to an array on which the backtrace will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>specifies the maximum number of addresses that can be stored in buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of addresses returned in buffer, which is not greater than <b>size</b>.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> All<br  />
<b>O/S</b>: Linux &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="gabd227ecb35493c392d80173180acd7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd227ecb35493c392d80173180acd7c7">&#9670;&nbsp;</a></span>PIN_ContextContainsState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_ContextContainsState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CONTEXT.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query if the specified <a class="el" href="structCONTEXT.html">CONTEXT</a> contains the specified PROCESSOR_STATE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context to be examined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>the PROCESSOR_STATE being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the PROCESSOR_STATE specified by state is contained in the ctxt</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="gade2217c59d6e6b5cad08a59afe3d879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade2217c59d6e6b5cad08a59afe3d879a">&#9670;&nbsp;</a></span>PIN_ExecuteAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_ExecuteAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A tool can call this API to abandon the current analysis function and resume execution of the calling thread at a new application register state. Note that this API does not return back to the caller's analysis function.</p>
<p>This API can be called from an analysis function or a replacement routine, but not from a callback.</p>
<p>When this API is called from an analysis function or replacement function, and if they execute the current routine or instruction being analyzed, then execution will resume at the instrumented routine or instruction and the analysis function will be called again. It is the pintool's responsibility to avoid going into an infinite loop of calls to the analysis function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>New application register state for the calling thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This API never returns.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga628d9e2f229dc5101142c94a5411d073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628d9e2f229dc5101142c94a5411d073">&#9670;&nbsp;</a></span>PIN_GetContextFPState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_GetContextFPState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFPSTATE.html">FPSTATE</a> *&#160;</td>
          <td class="paramname"><em>fpstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the floating point state of the specified context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context whose floating point state is retrieved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fpstate</td><td>pointer to the buffer that receives floating point state of the context. the <a class="el" href="structFPSTATE.html">FPSTATE</a> type is exposed by Pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga5b5aea73f92ac62e0767cb32bf8de4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b5aea73f92ac62e0767cb32bf8de4ed">&#9670;&nbsp;</a></span>PIN_GetContextReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ADDRINT PIN_GetContextReg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of the integer register or fp status/control register in the specified context. Note that fp registers such as fp-stack regs, xmm regs, ymm regs (when running with Intel(R) AVX support), can only be read using <a class="el" href="group__CONTEXT.html#ga44f8eeba2b8b874087441df1c3a530e2">PIN_GetContextRegval</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context whose register value is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is requested. This could be an integer register or a floating point register with integer values, like FP status/control register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of the register in the specified context</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga44f8eeba2b8b874087441df1c3a530e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f8eeba2b8b874087441df1c3a530e2">&#9670;&nbsp;</a></span>PIN_GetContextRegval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_GetContextRegval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of the requested register from the context. This function is applicable for all context registers (integer, fp etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>context whose register value is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is requested </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">val</td><td>an empty buffer which will hold the register value, see note below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is the user's responsibility to allocate and free the val buffer. The buffer size should be at least as wide as the register. The register size can be obtained using REG_Size.<br  />
 It is recommended to use a <a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a> object as the buffer (and pass a pointer to it). This will ensure that the buffer is large enough for any architectural register.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="gacbaac112366f778eedeb4b258a40558f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbaac112366f778eedeb4b258a40558f">&#9670;&nbsp;</a></span>PIN_GetFullContextRegsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__REG.html#ga8a33ca031ce83cf24d58dca8adf19f6c">REGSET</a> PIN_GetFullContextRegsSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get full REGSET.<br  />
When using IARG_PARTIAL_CONTEXT such a regset for both in and out REGSET will provide access to all registers including the ability to update them. Such a usage will provide better performance than using IARG_CONTEXT combined with <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt()</a>.</p>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga992f6073d146d7c5a61476f3a1ce474a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga992f6073d146d7c5a61476f3a1ce474a">&#9670;&nbsp;</a></span>PIN_GetInitialContextForUnwind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PIN_GetInitialContextForUnwind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cursor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>libbacktrace equivalent implementation</p>
<p>This function is the equivalent Pin version of unw_getcontext(): While unw_getcontext() generates a context for libunwind based on the native context, <a class="el" href="group__CONTEXT.html#ga992f6073d146d7c5a61476f3a1ce474a">PIN_GetInitialContextForUnwind()</a> generates a context for libunwind based on Pin <a class="el" href="structCONTEXT.html">CONTEXT</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxt</td><td>Pin context to convert to libunwind's context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>Points to valid object of type unw_cursor_t which was initialized using unw_init_local(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UNW_ESUCCESS in case of success.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> All<br  />
<b>O/S</b>: Linux &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="gabd0a55669ab303520f82e4f512e084f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd0a55669ab303520f82e4f512e084f9">&#9670;&nbsp;</a></span>PIN_SaveContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_SaveContext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxtFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxtTo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the <a class="el" href="structCONTEXT.html">CONTEXT</a> structure.<br  />
<a class="el" href="structCONTEXT.html">CONTEXT</a> structures supplied by Pin to the instrumentation callbacks are not "byte-copyable". The tool should use this function to copy the context provided by Pin and must not attempt to move it as raw memory bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctxtFrom</td><td><a class="el" href="structCONTEXT.html">CONTEXT</a> structure to copy from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ctxtTo</td><td><a class="el" href="structCONTEXT.html">CONTEXT</a> structure to copy into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga147e92f2d15f95bd43cb6c8ea19057f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga147e92f2d15f95bd43cb6c8ea19057f4">&#9670;&nbsp;</a></span>PIN_SetContextFPState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_SetContextFPState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFPSTATE.html">FPSTATE</a> *&#160;</td>
          <td class="paramname"><em>fpstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the given floating point state in the specified context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctxt</td><td>context whose floating point state is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fpstate</td><td>new floating point state of the context. the <a class="el" href="structFPSTATE.html">FPSTATE</a> type is exposed by Pin. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga83c0549f92440cf717c08689c47127cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83c0549f92440cf717c08689c47127cd">&#9670;&nbsp;</a></span>PIN_SetContextReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_SetContextReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the given value for the integer register or fp status/control register in the specified context. Note that fp registers such as fp-stack regs, xmm regs, ymm regs (when running with Intel(R) AVX support), can only be set using <a class="el" href="group__CONTEXT.html#gae96c2fa413d6009f9775cfebab49912f">PIN_SetContextRegval</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctxt</td><td>context whose register value is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is to be set. This could be an integer register or a floating point register with integer values, like FP status/control register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>new value of the register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="gae96c2fa413d6009f9775cfebab49912f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae96c2fa413d6009f9775cfebab49912f">&#9670;&nbsp;</a></span>PIN_SetContextRegval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID PIN_SetContextRegval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCONTEXT.html">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__REG.html#ga8f899d7ad1af070aae505a85cc998fa5">REG</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UINT8 *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the given value for the requested register in the context. This function is applicable for all context registers (integer, fp etc.). When this function is used from within a callback, e.g. THREAD_START_CALLBACK, the new context will take effect when the application continues. If this function is called from within an analysis routine, in order for the new context to take effect when the application continues one must do one of the following: Either use <a class="el" href="group__INST__ARGS.html#gga089c27ca15e9ff139dd3a3f8a6f8451dafbbb614d534693b8997f4a7db8fb7e29">IARG_PARTIAL_CONTEXT</a> and specify the registers which should be modified in the "out" REGSET. Or, use the IARG_CONTEXT and call <a class="el" href="group__CONTEXT.html#gade2217c59d6e6b5cad08a59afe3d879a">PIN_ExecuteAt</a> (don't forget to set REG_INST_PTR appropriately).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctxt</td><td>context whose register value is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register whose value is to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>buffer holding the new value of the register, see note below</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is the user's responsibility to allocate and free the val buffer. The buffer size should be at least as wide as the register. The register size can be obtained using REG_Size.<br  />
 It is recommended to use a <a class="el" href="unionPIN__REGISTER.html">PIN_REGISTER</a> object as the buffer (and pass a pointer to it). This will ensure that the buffer is large enough for any architectural register.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<a id="ga112f3ad5960ae4c2273c20abb6479b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga112f3ad5960ae4c2273c20abb6479b7a">&#9670;&nbsp;</a></span>PIN_SupportsProcessorState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL PIN_SupportsProcessorState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CONTEXT.html#ga479f2b92361e3794145bb90a1ea7e027">PROCESSOR_STATE</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query if Pin supports the specified PROCESSOR_STATE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>the PROCESSOR_STATE being queried </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the PROCESSOR_STATE specified by state is supported by Pin</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br  />
<b>O/S</b>: Linux, Windows &amp; macOS*<br  />
<b>CPU:</b> IA-32 and Intel(R) 64 architectures<br  />
</dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga15b5de856336b8d0452a63a746bb9c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b5de856336b8d0452a63a746bb9c61">&#9670;&nbsp;</a></span>ARCH_STATE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ADDRINT ARCH_STATE_SIZE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    (NUM_PHYSICAL_REGS + <a class="code" href="group__CONTEXT.html#gaead9b5f2f3655bbaf2776ad99e2ad279">NUM_SPECIAL_REGS</a>) * <span class="keyword">sizeof</span>(ADDRINT) + (<a class="code" href="group__CONTEXT.html#gaaf302a6d2cb4e89c0355540b1b0951d7">FPSTATE_SIZE</a> </div>
<div class="line">                                                                             </div>
<div class="line">                                                                             </div>
<div class="line">                                                                             </div>
<div class="line">                                                                + <a class="code" href="group__CONTEXT.html#ga0f5ad5017cf79566f740ff72e37dfeec">FPSTATE_ALIGNMENT</a>)</div>
</div><!-- fragment --><p>Size of the <a class="el" href="structCONTEXT.html">CONTEXT</a>'s architectural state in bytes </p>

</div>
</div>
<a id="ga63af62bca2c39be3fd6edd57ad2ac5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63af62bca2c39be3fd6edd57ad2ac5c3">&#9670;&nbsp;</a></span>DEFAULT_CONTEXT_IMPL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ADDRINT DEFAULT_CONTEXT_IMPL = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constant that designates default (canonical) <a class="el" href="structCONTEXT.html">CONTEXT</a> implementation. </p>

</div>
</div>
<a id="ga0f5ad5017cf79566f740ff72e37dfeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5ad5017cf79566f740ff72e37dfeec">&#9670;&nbsp;</a></span>FPSTATE_ALIGNMENT <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t FPSTATE_ALIGNMENT = 64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the alignment that the structure used to save the <a class="el" href="structFPSTATE.html">FPSTATE</a> The alignment required by xsave is 64, the alignment required by fxsave is 16 - so we use the larger </p>

</div>
</div>
<a id="ga0f5ad5017cf79566f740ff72e37dfeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f5ad5017cf79566f740ff72e37dfeec">&#9670;&nbsp;</a></span>FPSTATE_ALIGNMENT <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t FPSTATE_ALIGNMENT = 64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the alignment that the structure used to save the <a class="el" href="structFPSTATE.html">FPSTATE</a> The alignment required by xsave is 64, the alignment required by fxsave is 16 - so we use the larger </p>

</div>
</div>
<a id="gaaf302a6d2cb4e89c0355540b1b0951d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf302a6d2cb4e89c0355540b1b0951d7">&#9670;&nbsp;</a></span>FPSTATE_SIZE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t FPSTATE_SIZE = sizeof(<a class="el" href="structFPSTATE.html">FPSTATE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of Pin's (full) FP state structure. It is larger than the size of the structure used by the fxsave instruction (see FXSAVE). It may be larger than the size of the structure used by the xsave instruction, depending on the features enabled in the xstate_bv field in the extended header. </p>

</div>
</div>
<a id="gaaf302a6d2cb4e89c0355540b1b0951d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf302a6d2cb4e89c0355540b1b0951d7">&#9670;&nbsp;</a></span>FPSTATE_SIZE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t FPSTATE_SIZE = sizeof(<a class="el" href="structFPSTATE.html">FPSTATE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of Pin's (full) FP state structure. It is larger than the size of the structure used by the fxsave instruction (see FXSAVE). It may be larger than the size of the structure used by the xsave instruction, depending on the features enabled in the xstate_bv field in the extended header. </p>

</div>
</div>
<a id="gab6031aa9d9115234b9c49c6d5ab6d9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6031aa9d9115234b9c49c6d5ab6d9fa">&#9670;&nbsp;</a></span>NUM_CONTEXT_INT_REGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ADDRINT NUM_CONTEXT_INT_REGS = NUM_PHYSICAL_REGS + <a class="el" href="group__CONTEXT.html#gaead9b5f2f3655bbaf2776ad99e2ad279">NUM_SPECIAL_REGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of integer registers in <a class="el" href="structCONTEXT.html">CONTEXT</a> </p>

</div>
</div>
<a id="ga565196a3eaf9539660ef24845ca8c967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga565196a3eaf9539660ef24845ca8c967">&#9670;&nbsp;</a></span>NUM_CONTEXT_REGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ADDRINT NUM_CONTEXT_REGS = REG_LAST_CONTEXT_REG + 1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number of registers in <a class="el" href="structCONTEXT.html">CONTEXT</a> (app registers + tool registers + special) </p>

</div>
</div>
<a id="gaead9b5f2f3655bbaf2776ad99e2ad279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead9b5f2f3655bbaf2776ad99e2ad279">&#9670;&nbsp;</a></span>NUM_SPECIAL_REGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ADDRINT NUM_SPECIAL_REGS = 2 + NUM_SCRATCH_REGS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>REG_SEG_FS_BASE and REG_SEG_GS_BASE are represented as special IA-32/Intel(R) 64 architecture registers </p>

</div>
</div>
<a id="gad1b665d43ed8655d42cf86e474ceb5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1b665d43ed8655d42cf86e474ceb5ea">&#9670;&nbsp;</a></span>VSTATE_PADDING <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t VSTATE_PADDING = 128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the reserved bytes between the XSTATE and the VSTATE parts of the FP state area, as defined by the xsave layout in the SDM. </p>

</div>
</div>
<a id="gad1b665d43ed8655d42cf86e474ceb5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1b665d43ed8655d42cf86e474ceb5ea">&#9670;&nbsp;</a></span>VSTATE_PADDING <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t VSTATE_PADDING = 128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the reserved bytes between the XSTATE and the VSTATE parts of the FP state area, as defined by the xsave layout in the SDM. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__CONTEXT_html_gaead9b5f2f3655bbaf2776ad99e2ad279"><div class="ttname"><a href="group__CONTEXT.html#gaead9b5f2f3655bbaf2776ad99e2ad279">NUM_SPECIAL_REGS</a></div><div class="ttdeci">const ADDRINT NUM_SPECIAL_REGS</div><div class="ttdef"><b>Definition:</b> reg_ia32.PH:1091</div></div>
<div class="ttc" id="agroup__CONTEXT_html_gaaf302a6d2cb4e89c0355540b1b0951d7"><div class="ttname"><a href="group__CONTEXT.html#gaaf302a6d2cb4e89c0355540b1b0951d7">FPSTATE_SIZE</a></div><div class="ttdeci">const size_t FPSTATE_SIZE</div><div class="ttdef"><b>Definition:</b> fpstate_ia32.PH:83</div></div>
<div class="ttc" id="agroup__CONTEXT_html_ga0f5ad5017cf79566f740ff72e37dfeec"><div class="ttname"><a href="group__CONTEXT.html#ga0f5ad5017cf79566f740ff72e37dfeec">FPSTATE_ALIGNMENT</a></div><div class="ttdeci">const size_t FPSTATE_ALIGNMENT</div><div class="ttdef"><b>Definition:</b> fpstate_ia32.PH:90</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
